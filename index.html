<!DOCTYPE html>
<!-- Version 2.21 - Gestures apply to anchors -->
<html lang="en" data-version="2.21">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Durrell Masks</title>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a1a;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: white;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: 100%;
            max-width: 500px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Header bar - floats over content */
        .header-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 8px 12px;
            z-index: 150;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            font-size: 14px;
            pointer-events: none;
        }

        .header-bar > * {
            pointer-events: auto;
        }

        .header-bar .group-name {
            color: #888;
            cursor: pointer;
            flex: 1;
            border: 1px solid #888;
            padding: 4px 12px;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 50%;
        }

        .header-bar .header-btn {
            background: none;
            border: 1px solid #888;
            color: #888;
            padding: 4px 12px;
            font-size: 12px;
            cursor: pointer;
            white-space: nowrap;
        }

        .header-bar .header-btn:active {
            background: #888;
            color: white;
        }

        .header-bar .header-btn.active {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

        .menu-btn {
            background: none;
            border: 1px solid #888;
            color: #888;
            padding: 4px 10px;
            font-size: 16px;
            cursor: pointer;
        }

        .menu-btn.active {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px;
            z-index: 200;
            flex-direction: column;
            gap: 10px;
        }

        .dropdown-menu.open {
            display: flex;
        }

        .dropdown-menu .menu-item {
            background: none;
            border: 1px solid #888;
            color: #888;
            padding: 12px 16px;
            font-size: 14px;
            cursor: pointer;
            text-align: left;
        }

        .dropdown-menu .menu-item:active {
            background: #888;
            color: white;
        }

        .dropdown-menu .menu-item.active {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

        .share-btn {
            background: none;
            border: none;
            color: white;
            font-size: 10px;
            padding: 0 4px;
            cursor: pointer;
            text-decoration: underline;
        }

        .share-btn:active {
            color: #aaa;
        }

        .tap-hint {
            position: absolute;
            bottom: 8px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 10px;
            color: white;
            padding: 2px 0;
            z-index: 150;
            pointer-events: none;
        }

        /* View containers */
        .view {
            display: none;
            flex-direction: column;
            flex: 1;
        }

        .view.active {
            display: flex;
        }

        .camera-container {
            position: relative;
            width: 100%;
            flex: 1;
            min-height: 300px;
            overflow: hidden;
            background: #000;
            touch-action: none;
        }

        #video, #captureVideo {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translateX(-50%) translateY(-50%);
            width: 100%;
            height: auto;
            max-height: 100%;
            object-fit: contain;
        }

        #video {
            transform: translateX(-50%) translateY(-50%) scaleX(-1);
            -webkit-transform: translateX(-50%) translateY(-50%) scaleX(-1);
        }

        #debugCanvas, #captureCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #previewCanvas {
            display: block;
            width: 100%;
            height: auto;
            cursor: crosshair;
        }

        #previewCanvas.erase-mode {
            touch-action: pinch-zoom;
        }

        /* Checkerboard background for transparency preview */
        .transparency-bg {
            background-image:
                linear-gradient(45deg, #444 25%, transparent 25%),
                linear-gradient(-45deg, #444 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #444 75%),
                linear-gradient(-45deg, transparent 75%, #444 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #333;
        }

        .controls {
            padding: 12px;
            background: #222222;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .control-btn {
            padding: 4px 12px;
            border: 1px solid #888;
            background: none;
            color: #888;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }

        .control-btn:active {
            background: #888;
            color: white;
        }

        .control-btn.active {
            background: #888;
            color: white;
        }

        .control-btn.primary {
            background: #888;
            color: white;
            font-weight: 600;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-btn.success {
            background: #888;
            color: white;
        }

        .control-btn.eye-btn {
            min-width: 32px;
        }

        .control-btn.eye-btn.active {
            background: #4a4;
            border-color: #4a4;
            color: white;
        }

        .status {
            padding: 8px;
            text-align: center;
            font-size: 12px;
            color: #888;
            background: #141414;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #888;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 12px;
            font-size: 14px;
            color: #888;
        }

        /* Slider controls */
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: #141414;
        }

        .slider-row label {
            font-size: 12px;
            color: #888;
            min-width: 80px;
        }

        .slider-row input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }

        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-value {
            font-size: 12px;
            color: #888;
            min-width: 30px;
            text-align: right;
        }

        /* Preview states */
        .preview-container {
            position: relative;
            width: 100%;
            display: block;
        }

        .preview-container img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .hidden {
            display: none !important;
        }

        /* Saved masks gallery */
        .gallery {
            display: flex;
            gap: 8px;
            padding: 8px;
            overflow-x: auto;
            background: #141414;
        }

        .gallery-item {
            width: 60px;
            height: 60px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            flex-shrink: 0;
        }

        .gallery-item.selected {
            border-color: #888;
        }

        .gallery-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Points info bar */
        .points-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #1a3a5c;
            border-top: 1px solid #333333;
        }

        .points-info span {
            font-size: 12px;
            color: #aaa;
        }

        .control-btn.small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .control-btn.warning {
            background: #e67e22;
        }

        /* Gallery Overlay */
        .gallery-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1a1a1a;
            z-index: 150;
            display: flex;
            flex-direction: column;
        }

        .gallery-overlay.hidden {
            display: none;
        }

        .gallery-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #141414;
            font-weight: 600;
        }

        .gallery-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            padding: 12px;
            overflow-y: auto;
            align-content: start;
        }

        .gallery-mask-item {
            position: relative;
            aspect-ratio: 1;
            overflow: hidden;
            cursor: pointer;
            background: #222222;
            border: 2px solid transparent;
            transition: border-color 0.2s, transform 0.1s;
        }

        .gallery-mask-item:active {
            transform: scale(0.95);
        }

        .gallery-mask-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .gallery-mask-item:hover {
            border-color: #888;
        }

        .gallery-mask-item .delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 24px;
            height: 24px;
            background: #000;
            border: none;
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .gallery-mask-item .delete-btn:active {
            background: #333;
            color: white;
        }

        .gallery-mask-item .edit-btn {
            position: absolute;
            bottom: 5px;
            right: 5px;
            padding: 4px 10px;
            background: #000;
            border: none;
            color: #fff;
            font-size: 11px;
            cursor: pointer;
        }

        .gallery-mask-item .edit-btn:active {
            background: #333;
            color: white;
        }

        .gallery-loading, .gallery-empty {
            grid-column: 1 / -1;
            text-align: center;
            color: #888;
            padding: 40px;
        }

        /* Edit Mask Overlay */
        .edit-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1a1a1a;
            z-index: 200;
            display: flex;
            flex-direction: column;
        }

        .edit-overlay.hidden {
            display: none;
        }

        .edit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #141414;
            font-weight: 600;
        }

        .edit-canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #editMaskCanvas {
            max-width: 100%;
            max-height: 100%;
            cursor: crosshair;
        }

        .edit-controls {
            padding: 12px;
            background: #222222;
        }

        .anchor-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .anchor-btn {
            flex: 1;
            opacity: 0.6;
        }

        .anchor-btn.active {
            opacity: 1;
            background: #888;
        }

        .anchor-btn.placed {
            border: 2px solid #27ae60;
        }

        .edit-status {
            text-align: center;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 12px;
        }

        .edit-actions {
            display: flex;
            gap: 8px;
        }

        .edit-actions button {
            flex: 1;
        }

        /* Save Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .modal-overlay.hidden {
            display: none;
        }
        .modal {
            background: #1a1a1a;
            padding: 20px;
            width: 90%;
            max-width: 320px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .modal h3 {
            margin: 0 0 16px 0;
            font-size: 18px;
            text-align: left;
        }
        .modal-btn {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 14px 16px;
            margin: 8px 0;
            border: 1px solid #888;
            background: none;
            color: #888;
            font-size: 16px;
            cursor: pointer;
            text-align: left;
        }
        .modal-btn:active {
            background: #888;
            color: white;
        }
        .modal-btn.primary {
            background: #888;
            color: white;
        }
        .modal-btn .icon {
            font-size: 24px;
            margin-right: 12px;
        }
        .modal-btn.selected {
            background: #888;
            color: white;
        }
        .modal-divider {
            height: 1px;
            background: #333;
            margin: 16px 0;
        }
        .modal-cancel {
            display: block;
            width: 100%;
            padding: 12px 16px;
            margin-top: 12px;
            border: 1px solid #888;
            background: none;
            color: #888;
            font-size: 14px;
            cursor: pointer;
            text-align: left;
        }
        .group-list {
            max-height: 400px;
            overflow-y: auto;
        }
        .create-group-info {
            color: #888;
            font-size: 13px;
            text-align: left;
            margin: 0 0 16px 0;
            line-height: 1.4;
        }
        .group-name-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            background: #141414;
            border: 1px solid #888;
            color: #fff;
            box-sizing: border-box;
            margin-bottom: 12px;
        }
        .group-name-input:focus {
            outline: none;
            border-color: #fff;
        }
        .privacy-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #888;
            font-size: 14px;
            margin-bottom: 12px;
            cursor: pointer;
        }
        .privacy-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .group-preview {
            background: #0a0a0a;
            border: 1px solid #555;
            padding: 10px;
            font-family: monospace;
            font-size: 13px;
            text-align: center;
            margin-bottom: 16px;
            color: #aaa;
        }
        .group-preview span {
            color: #fff;
        }
        .qr-code {
            display: flex;
            justify-content: center;
            margin: 16px 0;
        }
        .qr-code canvas {
        }
        .share-url {
            background: none;
            padding: 8px 0;
            border: none;
            font-family: monospace;
            font-size: 11px;
            color: #888;
            word-break: break-all;
            text-align: center;
            margin: 8px 0;
        }

        /* ============================================
           TITLE SCREEN MODULE - KEEP SEPARATE
           ============================================ */
        #titleOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: opacity 0.5s ease;
        }

        #titleOverlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        #titleOverlay.hidden {
            display: none;
        }

        /* Made for mobile screen (shown on desktop) */
        #desktopBlock {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            z-index: 99999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #desktopBlock.hidden {
            display: none;
        }

        #desktopBlock h1 {
            color: black;
            font-size: 24px;
            font-weight: 400;
            text-align: center;
        }

        #titleImage {
            width: 100%;
            height: auto;
        }

        #titleTapHint {
            position: absolute;
            bottom: 40px;
            color: #666;
            font-size: 14px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Title Admin Panel */
        #titleAdminPanel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 10000;
            padding: 20px;
            overflow-y: auto;
        }

        #titleAdminPanel.hidden {
            display: none;
        }

        .title-admin-section {
            max-width: 500px;
            margin: 0 auto;
        }

        .title-admin-section h2 {
            color: #888;
            margin-bottom: 20px;
            text-align: center;
        }

        .title-preview {
            width: 100%;
            max-height: 300px;
            object-fit: contain;
            border: 1px solid #444;
            margin: 10px 0;
            background: #111;
        }

        .title-admin-btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            background: #333;
            border: 1px solid #666;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }

        .title-admin-btn.primary {
            background: #4a4;
            border-color: #4a4;
        }

        .title-admin-btn:disabled {
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <!-- Made for mobile screen (shown on desktop) -->
    <div id="desktopBlock" class="hidden">
        <h1>Made for iPhone & iPad</h1>
        <p style="color:#666;font-size:16px;margin-top:20px;">dbgh.uk/m</p>
    </div>

    <!-- ============================================
         TITLE SCREEN MODULE - KEEP SEPARATE
         ============================================ -->
    <div id="titleOverlay" class="hidden">
        <img id="titleImage" src="" alt="Title">
    </div>

    <!-- Title Admin Panel (accessed via ?title=admin) -->
    <div id="titleAdminPanel" class="hidden">
        <div class="title-admin-section">
            <h2>Title Screen Manager</h2>

            <div style="display:flex;gap:10px;justify-content:center;margin-bottom:10px;">
                <button class="title-admin-btn" id="titleTypePublicBtn" style="flex:1;">Default</button>
                <button class="title-admin-btn" id="titleTypeLocalBtn" style="flex:1;">Local</button>
                <button class="title-admin-btn" id="titleTypeGroupBtn" style="flex:1;">Group</button>
            </div>

            <select id="titleGroupSelect" style="display:none;width:100%;padding:12px;margin-bottom:10px;background:#333;color:#fff;border:none;border-radius:4px;font-size:16px;">
                <option value="">Select a group...</option>
            </select>

            <p id="titleTypeDesc" style="color:#666;text-align:center;margin-bottom:20px;">Default title for all groups</p>

            <img id="titlePreviewImg" class="title-preview" src="" alt="Preview">

            <input type="file" id="titleFileInput" accept="image/*" style="display:none;">
            <button class="title-admin-btn" id="titleSelectBtn">Select Image</button>
            <button class="title-admin-btn primary" id="titleUploadBtn" disabled>Upload to Server</button>
            <button class="title-admin-btn" id="titleRemoveBtn">Remove Title</button>
            <button class="title-admin-btn" id="titleCloseBtn">Close Admin</button>

            <div id="titleAdminStatus" style="color:#888;text-align:center;margin-top:20px;"></div>
        </div>
    </div>

    <!-- Save Modal -->
    <div class="modal-overlay hidden" id="saveModal">
        <div class="modal">
            <h3 style="text-align:center;margin:0 0 16px 0;color:#888;">Save To</h3>
            <button class="modal-btn" id="saveToPublicBtn" style="display:none;">Public-masks</button>
            <button class="modal-btn" id="saveToLocalBtn">Local-masks</button>
            <div id="saveGroupList"></div>
            <button class="modal-btn" id="saveToNewGroupBtn">New Group...</button>
            <button class="modal-cancel" id="saveCancelBtn">Cancel</button>
        </div>
    </div>

    <!-- Share Group Modal -->
    <div class="modal-overlay hidden" id="shareModal">
        <div class="modal">
            <button class="modal-btn primary" id="shareLinkBtn">
                <span class="icon">ðŸ“¤</span>
                <span id="shareButtonText">Share with friends</span>
            </button>
            <div class="share-url" id="shareUrl"></div>
            <div class="qr-code" id="qrCode"></div>
            <button class="modal-cancel" id="shareCancelBtn">Close</button>
        </div>
    </div>

    <!-- Create Group Modal -->
    <div class="modal-overlay hidden" id="createGroupModal">
        <div class="modal">
            <h3>Create New Group</h3>
            <p class="create-group-info">
                Anyone with the group link can view and add masks.
                Use a unique name or add a random code for privacy.
            </p>
            <input type="text" id="createGroupNameInput" class="group-name-input" placeholder="Enter group name..." maxlength="30">
            <label class="privacy-toggle">
                <input type="checkbox" id="addRandomSuffix" checked>
                <span>Add random code for privacy</span>
            </label>
            <div class="group-preview">
                Will create: <span id="groupNamePreview">-masks</span>
            </div>
            <button class="modal-btn primary" id="confirmCreateGroupBtn">Create Group</button>
            <button class="modal-cancel" id="cancelCreateGroupBtn">Cancel</button>
        </div>
    </div>

    <!-- Group Picker Modal -->
    <div class="modal-overlay hidden" id="groupPickerModal">
        <div class="modal">
            <h3>Choose a Group</h3>
            <div class="group-list" id="groupPickerList"></div>
            <div class="modal-divider" id="pickerShareSection" style="display:none;"></div>
            <button class="modal-btn" id="pickerShareBtn" style="display:none;">Share This Group</button>
            <div class="modal-divider" id="pickerAdminSection" style="display:none;"></div>
            <button class="modal-btn" id="pickerAdminBtn" style="display:none;">Admin Panel</button>
            <button class="modal-cancel" id="groupPickerCancelBtn">Cancel</button>
        </div>
    </div>

    <!-- Group Menu Modal -->
    <div class="modal-overlay hidden" id="groupMenuModal">
        <div class="modal">
            <div style="text-align:center;font-size:10px;color:#555;margin-bottom:12px;">v5.1</div>
            <button class="modal-btn" id="publicGroupBtn">Public-masks</button>
            <button class="modal-btn" id="localGroupBtn">Local-masks</button>
            <button class="modal-btn" id="newGroupBtn">New Mask Group</button>
            <div id="savedGroupsList"></div>

            <div class="modal-divider" id="shareSection" style="display:none;"></div>
            <button class="modal-btn" id="shareGroupBtn" style="display:none;">
                Share This Group
            </button>

            <div class="modal-divider"></div>
            <button class="modal-btn" id="exportLocalBtn">Export Local Masks</button>
            <input type="file" id="importLocalInput" accept=".json,.maskpack" style="display:none;">
            <button class="modal-btn" id="importLocalBtn">Import Masks</button>

            <div class="modal-divider" id="adminSection" style="display:none;"></div>
            <button class="modal-btn" id="adminPanelBtn" style="display:none;">Admin Panel</button>

            <button class="modal-cancel" id="groupCloseBtn">Close</button>
        </div>
    </div>

    <!-- Admin Panel Modal -->
    <div class="modal-overlay hidden" id="adminPanelModal">
        <div class="modal" style="max-height:90vh;display:flex;flex-direction:column;">
            <h3 style="flex-shrink:0;">Admin Panel</h3>

            <div style="margin-bottom:16px;flex-shrink:0;">
                <button class="modal-btn" id="createPublicGroupBtn">Create Public Group</button>
                <button class="modal-btn" id="createFriendGroupBtn">Create Friend Group</button>
            </div>

            <div class="modal-divider" style="flex-shrink:0;"></div>
            <div style="margin:12px 0 8px 0;font-size:12px;flex-shrink:0;">All Groups</div>
            <div id="adminGroupsList" style="flex:1;overflow-y:auto;min-height:100px;"></div>

            <div class="modal-divider" style="flex-shrink:0;"></div>
            <button class="modal-cancel" id="adminPanelCloseBtn" style="flex-shrink:0;">Close</button>
            <button class="modal-btn" id="adminLogoutBtn" style="margin-top:8px;background:#666;flex-shrink:0;">Log out of admin</button>
        </div>
    </div>

    <div id="debugInfo" style="position:fixed;top:50px;left:10px;right:10px;background:rgba(255,0,0,0.9);color:#fff;font-family:monospace;font-size:14px;padding:10px;z-index:9999;"></div>
    <div class="container">
        <!-- Face Tracking View -->
        <div class="view active" id="trackView">
            <div class="camera-container">
                <!-- Header floats over video -->
                <div class="header-bar" id="headerBar">
                    <button class="menu-btn" id="menuBtn">Menu</button>
                    <div class="dropdown-menu" id="dropdownMenu">
                        <div style="font-size:10px;color:#888;padding:4px 8px;display:flex;justify-content:space-between;">
                            <span>tap screen to change masks</span>
                            <span id="menuGroupName">Local-masks</span>
                        </div>
                        <button class="menu-item" id="groupNameHeader">Choose a different group of masks</button>
                        <button class="menu-item" id="galleryBtn">Pick a different mask</button>
                        <button class="menu-item" id="makeMaskBtn">Create your own mask</button>
                        <button class="menu-item" id="editPosBtn" style="display:none;">Align mask to your face</button>
                        <button class="menu-item" id="headerShareBtn">Share Mask Maker with friends</button>
                        <button class="menu-item" id="menuAdminBtn" style="display:none;">Admin Panel</button>
                    </div>
                </div>
                <div class="tap-hint"><span style="opacity:0.5">v2.58-dev</span></div>
                <video id="video" autoplay playsinline muted></video>
                <canvas id="debugCanvas"></canvas>
                <div id="tapOverlay" style="position:absolute;top:0;left:0;width:100%;height:100%;z-index:100;touch-action:none;"></div>
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div class="loading-text" id="loadingText">Initializing...</div>
                </div>
            </div>

            <!-- Mask Gallery Overlay -->
            <div class="gallery-overlay hidden" id="galleryOverlay">
                <div class="gallery-header">
                    <span>Group: <span id="groupName" style="color:#888"></span> <span id="maskCount" style="opacity:0.7"></span></span>
                    <button class="control-btn small" id="closeGalleryBtn">Close</button>
                </div>
                <div class="gallery-grid" id="galleryGrid">
                    <div class="gallery-loading">Loading masks...</div>
                </div>
            </div>

            <!-- Edit Mask Overlay -->
            <div class="edit-overlay hidden" id="editMaskOverlay">
                <div class="edit-header">
                    <button class="control-btn small" id="closeEditBtn">Done</button>
                    <span>Edit Anchor Points</span>
                </div>
                <div class="edit-canvas-container transparency-bg">
                    <canvas id="editMaskCanvas"></canvas>
                    <video id="textureVideo" autoplay playsinline muted style="display:none"></video>
                </div>
                <div class="edit-controls" id="anchorControls">
                    <div class="anchor-buttons">
                        <button class="control-btn anchor-btn active" data-anchor="leftEye">L Eye</button>
                        <button class="control-btn anchor-btn" data-anchor="rightEye">R Eye</button>
                    </div>
                    <div class="edit-status" id="editStatus">Tap on RIGHT side of mask for right eye</div>
                    <div class="edit-actions">
                        <button class="control-btn" id="resetPointsBtn">Reset All</button>
                        <button class="control-btn" id="textureBtn">Change Texture</button>
                        <button class="control-btn primary" id="saveEditBtn">Save</button>
                    </div>
                </div>
                <div class="edit-controls hidden" id="textureControls">
                    <div class="edit-status" id="textureStatus">Point camera at texture and tap Capture</div>
                    <div class="edit-actions">
                        <button class="control-btn" id="cancelTextureBtn">Cancel</button>
                        <button class="control-btn success" id="captureTextureBtn">Capture Texture</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Capture/Create Mask View -->
        <div class="view" id="captureView">
            <!-- Edit controls (above canvas so always accessible) -->
            <div class="controls hidden" id="editControls" style="padding:4px 8px;margin-bottom:0;gap:4px;">
                <button class="control-btn" id="closeCreateBtn">Close</button>
                <button class="control-btn" id="retakeBtn">Retake</button>
                <button class="control-btn" id="eraseBtn">Erase</button>
                <button class="control-btn" id="createTextureBtn">Fill - Camera</button>
                <!-- <button class="control-btn" id="strokeBtn">Stroke</button> -->
                <button class="control-btn primary" id="saveBtn">Save</button>
            </div>
            <div class="hidden" id="editHelpText" style="padding:1px 8px;background:#222;color:#888;font-size:11px;">Use Tolerance, Erase or tap the screen to cut out background</div>
            <div class="slider-row" id="toleranceRow" style="margin-top:0;padding:1px 8px 6px 8px;">
                <label>Tolerance:</label>
                <input type="range" id="toleranceSlider" min="10" max="150" value="60">
                <span class="slider-value" id="toleranceValue">60</span>
            </div>
            <div class="controls hidden" id="createTextureControls">
                <button class="control-btn" id="cancelCreateTextureBtn">Cancel</button>
                <button class="control-btn success" id="captureCreateTextureBtn">Capture Texture</button>
            </div>
            <!-- Eye controls - buttons hidden but div needed for code flow -->
            <div class="controls hidden" id="eyeControls">
                <button class="control-btn eye-btn" id="eyeRightBtn" style="display:none;">Left Eye Location</button>
                <button class="control-btn eye-btn" id="eyeLeftBtn" style="display:none;">Right Eye Location</button>
            </div>

            <div class="controls" id="captureControls" style="padding:6px 8px;gap:4px;">
                <button class="control-btn" id="closeCaptureBtn">Close</button>
                <button class="control-btn" id="loadPictureBtn">Load Picture</button>
                <button class="control-btn primary" id="takePhotoBtn">Take Photo</button>
                <input type="file" id="pictureInput" accept="image/*" style="display:none;">
            </div>

            <!-- Camera state -->
            <div id="captureCamera" class="camera-container">
                <video id="captureVideo" autoplay playsinline muted></video>
            </div>

            <!-- Preview state (after photo taken) -->
            <div id="capturePreview" class="preview-container transparency-bg hidden">
                <canvas id="previewCanvas"></canvas>
            </div>

            <div class="status" id="captureStatus">Point camera at your drawing and tap "Take Photo"</div>
        </div>
    </div>

    <script>
        document.getElementById('loadingText').textContent = 'Starting...';
        window.onerror = function(msg, url, line) {
            document.getElementById('loadingText').textContent = 'JS Error: ' + msg;
        };
    </script>

    <script type="module" onerror="document.getElementById('loadingText').textContent='Module failed'">
        document.getElementById('loadingText').textContent = 'Loading...';
        const { FaceLandmarker, FilesetResolver } = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/vision_bundle.mjs');
        document.getElementById('loadingText').textContent = 'Setting up...';

        // ============================================
        // LANDMARK INDICES
        // ============================================

        const LEFT_EYE_CENTER = 468;
        const RIGHT_EYE_CENTER = 473;
        const LEFT_EYE_INNER = 133;
        const LEFT_EYE_OUTER = 33;
        const RIGHT_EYE_INNER = 362;
        const RIGHT_EYE_OUTER = 263;
        const MOUTH_LEFT = 61;
        const MOUTH_RIGHT = 291;
        const UPPER_LIP_TOP = 13;
        const LOWER_LIP_BOTTOM = 14;
        const FACE_OVAL = [
            10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288,
            397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136,
            172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109
        ];
        const LEFT_EAR_TOP = 127;
        const LEFT_EAR_BOTTOM = 234;
        const RIGHT_EAR_TOP = 356;
        const RIGHT_EAR_BOTTOM = 454;

        // ============================================
        // STATE
        // ============================================

        let faceLandmarker = null;
        let trackVideo = null;
        let trackCanvas = null;
        let trackCtx = null;
        let isTracking = false;
        let trackAnimationId = null;

        let captureVideo = null;
        let captureStream = null;
        let previewCanvas = null;
        let previewCtx = null;
        let originalImageData = null;
        let currentView = 'track';

        // Saved masks
        const savedMasks = [];

        console.log('Durrell Masks v2.58-dev loaded');

        // Anchor point placement state (eyes and mouth)
        let eyePointMode = false;
        let placingEye = null;  // 'left', 'right', or null
        let eraseMode = false;
        let isErasing = false;
        let eraserSize = 25;
        let savedToleranceValue = 60;
        let eyePoints = { left: null, right: null };

        // Current mask state (after background removal and hole cuts)
        let currentMaskData = null;

        // Loaded mask for face tracking
        let loadedMask = null;  // { image: HTMLImageElement, anchors: { leftEye, rightEye } }
        let loadedMaskId = null;  // ID of currently loaded mask (for saving)
        let maskImage = null;

        // Track which masks have been unlocked for gesture editing (per session)
        const unlockedMasks = new Set();

        // Save current mask's anchors (local or remote for admin)
        async function saveCurrentMaskAnchors() {
            if (!loadedMask || !loadedMaskId) return;

            if (currentGroup === 'local') {
                // Local masks - save to localStorage
                const localMasks = JSON.parse(localStorage.getItem('local_masks') || '[]');
                const maskIndex = localMasks.findIndex(m => m.id === loadedMaskId);
                if (maskIndex !== -1) {
                    localMasks[maskIndex].anchors = loadedMask.anchors;
                    localStorage.setItem('local_masks', JSON.stringify(localMasks));
                }
            } else if (!isAdmin || !galleryManifest) {
                return;
            } else {
                // Remote masks for admin - upload updated mask
                const mask = galleryManifest.masks.find(m => m.id === loadedMaskId);
                if (!mask) {
                    updateStatus('track', 'Save failed: mask not found');
                    return;
                }
                if (!maskImage) {
                    updateStatus('track', 'Save failed: no image');
                    return;
                }

                updateStatus('track', 'Saving position...');

                try {
                    // Convert current maskImage to data URL
                    const canvas = document.createElement('canvas');
                    canvas.width = maskImage.width;
                    canvas.height = maskImage.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(maskImage, 0, 0);

                    let imageDataUrl;
                    try {
                        imageDataUrl = canvas.toDataURL('image/png');
                    } catch (e) {
                        updateStatus('track', 'Save failed: cross-origin');
                        return;
                    }

                    // Upload with new anchors
                    let uploadUrl = `${WORKER_URL}/upload`;
                    uploadUrl = withAdmin(uploadUrl);

                    const response = await fetch(uploadUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            group: currentGroup,
                            name: mask.name,
                            imageData: imageDataUrl,
                            anchors: loadedMask.anchors
                        })
                    });

                    const result = await response.json();

                    if (response.ok && result.mask) {
                        // Delete old version
                        const oldId = mask.id;
                        await fetch(withAdmin(`${WORKER_URL}/mask`), {
                            method: 'DELETE',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                group: currentGroup,
                                maskId: oldId
                            })
                        });

                        // Update loaded mask ID to the new one
                        loadedMaskId = result.mask.id;

                        // Reload manifest to get fresh data
                        await loadGalleryManifest();

                        updateStatus('track', 'Position saved!');
                    } else {
                        updateStatus('track', 'Save failed: ' + (result.error || 'upload error'));
                    }
                } catch (error) {
                    updateStatus('track', 'Save failed: ' + error.message);
                }
            }
        }

        // Direct anchor adjustment via gestures (scale, rotate, and pan)
        function adjustAnchors(scaleRatio, rotationDelta, panX, panY) {
            if (!loadedMask || !loadedMask.anchors) return;
            const anchors = loadedMask.anchors;

            // Get current anchor positions (normalized 0-1)
            const leftX = anchors.leftEye.x;
            const leftY = anchors.leftEye.y;
            const rightX = anchors.rightEye.x;
            const rightY = anchors.rightEye.y;

            // Calculate midpoint
            let midX = (leftX + rightX) / 2;
            let midY = (leftY + rightY) / 2;

            // Apply pan (convert screen pixels to normalized)
            // Sensitivity: ~500px pan = full mask width shift
            const panSensitivity = 0.002;
            midX -= panX * panSensitivity;
            midY -= panY * panSensitivity;

            // Vector from mid to right anchor
            let dx = rightX - (leftX + rightX) / 2;
            let dy = rightY - (leftY + rightY) / 2;

            // Apply scale (closer anchors = bigger mask on face)
            dx /= scaleRatio;
            dy /= scaleRatio;

            // Apply rotation (negated so mask rotates same direction as gesture)
            const cos = Math.cos(-rotationDelta);
            const sin = Math.sin(-rotationDelta);
            const newDx = dx * cos - dy * sin;
            const newDy = dx * sin + dy * cos;

            // Update anchors (clamped to 0-1)
            anchors.leftEye.x = Math.max(0, Math.min(1, midX - newDx));
            anchors.leftEye.y = Math.max(0, Math.min(1, midY - newDy));
            anchors.rightEye.x = Math.max(0, Math.min(1, midX + newDx));
            anchors.rightEye.y = Math.max(0, Math.min(1, midY + newDy));
        }

        // Stroke effect
        let strokeEnabled = false;
        let strokeCanvas = null;  // White silhouette for stroke effect

        // Gallery
        let galleryManifest = null;
        let currentMaskIndex = 0;

        // Worker config for group-based mask storage
        const WORKER_URL = 'https://mask-worker.dbgh.workers.dev';

        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const branchParam = urlParams.get('branch');

        // Helper to build URLs preserving branch parameter
        function buildUrl(params, hash = '') {
            const url = new URL(window.location.pathname, window.location.origin);
            if (branchParam) url.searchParams.set('branch', branchParam);
            for (const [key, value] of Object.entries(params)) {
                if (value !== null && value !== undefined) {
                    url.searchParams.set(key, value);
                }
            }
            return url.toString() + hash;
        }

        // Admin mode - use ?admin=<code> to unlock admin features
        // Code is verified against Worker, not hardcoded here
        const adminCodeParam = urlParams.get('admin');
        let isAdmin = localStorage.getItem('mask_admin') === 'true';
        let storedAdminCode = localStorage.getItem('mask_admin_code') || '';

        // Verify admin code against Worker if provided in URL
        async function verifyAdminCode(code) {
            try {
                const response = await fetch(`${WORKER_URL}/auth/verify`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code })
                });
                const data = await response.json();
                return data.valid === true;
            } catch (e) {
                console.error('Admin verification failed:', e);
                return false;
            }
        }

        // If admin code in URL, verify it
        if (adminCodeParam) {
            // Show loading while verifying
            (async () => {
                const valid = await verifyAdminCode(adminCodeParam);
                if (valid) {
                    localStorage.setItem('mask_admin', 'true');
                    localStorage.setItem('mask_admin_code', adminCodeParam);
                    isAdmin = true;
                    storedAdminCode = adminCodeParam;
                    updateHeader();
                    // Clean URL to remove admin code
                    const cleanUrl = new URL(window.location.href);
                    cleanUrl.searchParams.delete('admin');
                    window.history.replaceState({}, '', cleanUrl.toString());
                } else {
                    alert('Invalid admin code');
                    localStorage.removeItem('mask_admin');
                    localStorage.removeItem('mask_admin_code');
                }
            })();
        }

        // Handle friend token - ?friend=xxx
        const friendToken = urlParams.get('friend');
        let currentGroupToken = null;
        if (friendToken) {
            // Store friend token for this group
            const friendTokens = JSON.parse(localStorage.getItem('friend_tokens') || '{}');
            friendTokens[friendToken] = true;
            localStorage.setItem('friend_tokens', JSON.stringify(friendTokens));
            currentGroupToken = friendToken;
        }

        // Get group from URL param, or use last group, or default to local
        // ?friend=xxx means group is the friend token
        // ?group=xxx means regular group (public or legacy)
        const currentGroup = friendToken || urlParams.get('group') || localStorage.getItem('mask_last_group') || 'local';

        // Check if current group has a friend token stored
        if (!currentGroupToken && currentGroup !== 'local') {
            const friendTokens = JSON.parse(localStorage.getItem('friend_tokens') || '{}');
            if (friendTokens[currentGroup]) {
                currentGroupToken = currentGroup;
            }
        }

        // Check if this is a newly created group (show share modal later)
        const isNewGroup = urlParams.get('new') === '1';

        // Save current group as last used (not for friend links on first visit)
        if (!friendToken) {
            localStorage.setItem('mask_last_group', currentGroup);
        }

        // Current group display name (will be updated when we fetch group info)
        let currentGroupName = currentGroup;
        let currentGroupType = 'unknown'; // 'public', 'friend', or 'local'

        if (currentGroup === 'local') {
            currentGroupName = 'Local-masks';
            currentGroupType = 'local';
        } else if (currentGroup === 'public') {
            currentGroupName = 'Public-masks';
            currentGroupType = 'public';
        }

        // Position editing mode
        let isEditingPosition = false;

        // Update header bar
        function updateHeader() {
            // Show Edit Position button if user can edit (local or admin)
            const editPosBtn = document.getElementById('editPosBtn');
            const canEdit = currentGroup === 'local' || isAdmin;
            editPosBtn.style.display = canEdit ? '' : 'none';
            editPosBtn.classList.toggle('active', isEditingPosition);

            // Update menu button to show admin indicator
            const menuBtn = document.getElementById('menuBtn');
            menuBtn.textContent = isAdmin ? '* Menu' : 'Menu';

            // Update group name in menu header
            const menuGroupName = document.getElementById('menuGroupName');
            menuGroupName.textContent = currentGroupName;

            // Show Admin Panel button only for admins
            const menuAdminBtn = document.getElementById('menuAdminBtn');
            menuAdminBtn.style.display = isAdmin ? '' : 'none';

            // Update Create mask button text based on whether user can create in current group
            const makeMaskBtn = document.getElementById('makeMaskBtn');
            const canCreateInGroup = currentGroup !== 'public' || isAdmin;
            makeMaskBtn.textContent = canCreateInGroup ? 'Create your own mask' : 'Make your own Local-mask';
        }
        updateHeader();

        // Menu toggle
        const menuBtn = document.getElementById('menuBtn');
        const dropdownMenu = document.getElementById('dropdownMenu');

        function toggleMenu(show) {
            const isOpen = show !== undefined ? show : !dropdownMenu.classList.contains('open');
            dropdownMenu.classList.toggle('open', isOpen);
            menuBtn.classList.toggle('active', isOpen);
        }

        menuBtn.addEventListener('click', () => toggleMenu());

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!menuBtn.contains(e.target) && !dropdownMenu.contains(e.target)) {
                toggleMenu(false);
            }
        });

        // Edit Position button handler
        document.getElementById('editPosBtn').addEventListener('click', () => {
            isEditingPosition = !isEditingPosition;
            updateHeader();
            toggleMenu(false);
        });

        // Admin Panel button handler
        document.getElementById('menuAdminBtn').addEventListener('click', () => {
            toggleMenu(false);
            showAdminPanel();
        });

        // Helper: Add admin param to URL if admin
        function withAdmin(url) {
            const code = localStorage.getItem('mask_admin_code');
            if (isAdmin && code) {
                const sep = url.includes('?') ? '&' : '?';
                return url + sep + 'admin=' + encodeURIComponent(code);
            }
            return url;
        }

        // Helper: Add token to URL if we have one for this group
        function withToken(url, groupId) {
            const friendTokens = JSON.parse(localStorage.getItem('friend_tokens') || '{}');
            if (friendTokens[groupId]) {
                const sep = url.includes('?') ? '&' : '?';
                return url + sep + 'token=' + groupId;
            }
            return url;
        }

        // Make Mask button - goes directly to capture for current group
        document.getElementById('makeMaskBtn').addEventListener('click', () => {
            const dbg = document.getElementById('debugInfo');
            try {
                dbg.textContent = 'CLICKED! group=' + currentGroup + ' admin=' + isAdmin;
                toggleMenu(false);
                // Non-admins can't make masks for public - switch to local instead
                if (currentGroup === 'public' && !isAdmin) {
                    dbg.textContent += ' | SWITCHING';
                    currentGroup = 'local';
                    currentGroupName = 'Local-masks';
                    currentGroupType = 'local';
                    localStorage.setItem('selectedGroup', 'local');
                    dbg.textContent += ' | vars set';
                    updateHeader();
                    dbg.textContent += ' | header updated';
                }
                dbg.textContent += ' | calling switchView';
                switchView('capture');
                dbg.textContent += ' | DONE';
            } catch (e) {
                dbg.textContent = 'ERROR: ' + e.message;
            }
        });

        // Legacy constants (kept for compatibility)
        const GITHUB_REPO = 'DurrellBishop-iCloud/m';
        const GITHUB_BRANCH = 'main';

        // ============================================
        // TAB NAVIGATION
        // ============================================

        let isEditingExistingMask = false;

        function switchView(viewId, skipCamera = false) {
            // Update views
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(viewId + 'View').classList.add('active');

            currentView = viewId;

            // Handle camera switching
            if (viewId === 'capture') {
                stopTracking();
                // Don't start camera if we're editing an existing mask
                if (!skipCamera && !isEditingExistingMask) {
                    startCaptureCamera();
                }
            } else {
                stopCaptureCamera();
                isEditingExistingMask = false; // Reset when leaving capture view
                // Restart face tracking when returning to track view
                if (faceLandmarker && !isTracking) {
                    startTracking();
                }
            }
        }

        // ============================================
        // FACE TRACKING (same as before)
        // ============================================

        async function initializeFaceLandmarker() {
            updateStatus('track', 'Loading face detection model...');

            const filesetResolver = await FilesetResolver.forVisionTasks(
                'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm'
            );

            faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                baseOptions: {
                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
                    delegate: 'GPU'
                },
                runningMode: 'VIDEO',
                numFaces: 1,
                minFaceDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5,
                outputFaceBlendshapes: false,
                outputFacialTransformationMatrixes: false
            });

            updateStatus('track', 'Model loaded - Starting camera...');
            hideLoading();

            // Auto-start tracking only if we're in track view
            if (currentView === 'track') {
                startTracking();
            }
        }

        async function startTracking() {
            try {
                updateStatus('track', 'Requesting camera access...');
                showLoading('Accessing camera...');

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } },
                    audio: false
                });

                trackVideo = document.getElementById('video');
                trackVideo.srcObject = stream;
                await new Promise(r => trackVideo.onloadedmetadata = r);
                await trackVideo.play();

                trackCanvas = document.getElementById('debugCanvas');
                trackCtx = trackCanvas.getContext('2d');
                resizeTrackCanvas();

                hideLoading();
                isTracking = true;

                detectFaces();
            } catch (error) {
                console.error('Camera error:', error);
                updateStatus('track', 'Camera error: ' + error.message);
                hideLoading();
            }
        }

        function stopTracking() {
            isTracking = false;
            if (trackAnimationId) {
                cancelAnimationFrame(trackAnimationId);
                trackAnimationId = null;
            }
            if (trackVideo && trackVideo.srcObject) {
                trackVideo.srcObject.getTracks().forEach(t => t.stop());
                trackVideo.srcObject = null;
            }
            if (trackCtx) {
                trackCtx.clearRect(0, 0, trackCanvas.width, trackCanvas.height);
            }
        }

        function resizeTrackCanvas() {
            const container = trackCanvas.parentElement;
            const rect = container.getBoundingClientRect();
            trackCanvas.width = rect.width;
            trackCanvas.height = rect.height;
        }

        function detectFaces() {
            if (!isTracking || !faceLandmarker || !trackVideo) return;

            try {
                const results = faceLandmarker.detectForVideo(trackVideo, performance.now());
                trackCtx.clearRect(0, 0, trackCanvas.width, trackCanvas.height);

                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    const landmarks = results.faceLandmarks[0];

                    // Draw mask
                    if (loadedMask && maskImage) {
                        drawMaskOverlay(landmarks);
                    }

                    // Debug overlay disabled for now - uncomment to show face landmarks
                    // drawDebugOverlay(landmarks);
                }
            } catch (error) {
                console.error('Detection error:', error);
            }

            trackAnimationId = requestAnimationFrame(detectFaces);
        }

        function drawDebugOverlay(landmarks) {
            const w = trackCanvas.width;
            const h = trackCanvas.height;
            const toCanvas = (idx) => ({
                x: (1 - landmarks[idx].x) * w,
                y: landmarks[idx].y * h
            });

            // Face oval
            trackCtx.strokeStyle = 'rgba(0, 255, 255, 0.7)';
            trackCtx.lineWidth = 2;
            trackCtx.beginPath();
            const first = toCanvas(FACE_OVAL[0]);
            trackCtx.moveTo(first.x, first.y);
            for (let i = 1; i < FACE_OVAL.length; i++) {
                const pt = toCanvas(FACE_OVAL[i]);
                trackCtx.lineTo(pt.x, pt.y);
            }
            trackCtx.closePath();
            trackCtx.stroke();

            // Eyes
            trackCtx.fillStyle = '#00ff00';
            [LEFT_EYE_CENTER, RIGHT_EYE_CENTER].forEach(idx => {
                const pt = toCanvas(idx);
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 6, 0, Math.PI * 2);
                trackCtx.fill();
            });

            trackCtx.fillStyle = '#ffff00';
            [LEFT_EYE_INNER, LEFT_EYE_OUTER, RIGHT_EYE_INNER, RIGHT_EYE_OUTER].forEach(idx => {
                const pt = toCanvas(idx);
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 3, 0, Math.PI * 2);
                trackCtx.fill();
            });

            // Mouth
            const mL = toCanvas(MOUTH_LEFT);
            const mR = toCanvas(MOUTH_RIGHT);
            trackCtx.strokeStyle = '#ff00ff';
            trackCtx.lineWidth = 3;
            trackCtx.beginPath();
            trackCtx.moveTo(mL.x, mL.y);
            trackCtx.lineTo(mR.x, mR.y);
            trackCtx.stroke();

            trackCtx.fillStyle = '#ff00ff';
            [mL, mR].forEach(pt => {
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                trackCtx.fill();
            });

            const uL = toCanvas(UPPER_LIP_TOP);
            const lL = toCanvas(LOWER_LIP_BOTTOM);
            trackCtx.fillStyle = '#ff6600';
            [uL, lL].forEach(pt => {
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                trackCtx.fill();
            });

            // Ears
            trackCtx.strokeStyle = '#ffff00';
            trackCtx.lineWidth = 3;
            const leT = toCanvas(LEFT_EAR_TOP);
            const leB = toCanvas(LEFT_EAR_BOTTOM);
            trackCtx.beginPath();
            trackCtx.moveTo(leT.x, leT.y);
            trackCtx.lineTo(leB.x, leB.y);
            trackCtx.stroke();

            const reT = toCanvas(RIGHT_EAR_TOP);
            const reB = toCanvas(RIGHT_EAR_BOTTOM);
            trackCtx.beginPath();
            trackCtx.moveTo(reT.x, reT.y);
            trackCtx.lineTo(reB.x, reB.y);
            trackCtx.stroke();

            trackCtx.fillStyle = '#ffff00';
            [leT, leB, reT, reB].forEach(pt => {
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                trackCtx.fill();
            });
        }

        function drawMaskOverlay(landmarks) {
            if (!loadedMask || !maskImage) return;

            const w = trackCanvas.width;
            const h = trackCanvas.height;

            // Get detected eye positions (mirrored for selfie view)
            // In mirrored view: user's left eye appears on LEFT of screen
            const leftEye = {
                x: (1 - landmarks[LEFT_EYE_CENTER].x) * w,
                y: landmarks[LEFT_EYE_CENTER].y * h
            };
            const rightEye = {
                x: (1 - landmarks[RIGHT_EYE_CENTER].x) * w,
                y: landmarks[RIGHT_EYE_CENTER].y * h
            };

            // Get detected mouth positions (mirrored)
            const leftMouth = {
                x: (1 - landmarks[MOUTH_LEFT].x) * w,
                y: landmarks[MOUTH_LEFT].y * h
            };
            const rightMouth = {
                x: (1 - landmarks[MOUTH_RIGHT].x) * w,
                y: landmarks[MOUTH_RIGHT].y * h
            };

            // Get mask anchor points (no X flip - mask is drawn unmirrored)
            const maskLeftEye = {
                x: loadedMask.anchors.leftEye.x * loadedMask.width,
                y: loadedMask.anchors.leftEye.y * loadedMask.height
            };
            const maskRightEye = {
                x: loadedMask.anchors.rightEye.x * loadedMask.width,
                y: loadedMask.anchors.rightEye.y * loadedMask.height
            };

            // Calculate distances between eyes
            const faceEyeDist = Math.sqrt(
                Math.pow(rightEye.x - leftEye.x, 2) +
                Math.pow(rightEye.y - leftEye.y, 2)
            );
            const maskEyeDist = Math.sqrt(
                Math.pow(maskRightEye.x - maskLeftEye.x, 2) +
                Math.pow(maskRightEye.y - maskLeftEye.y, 2)
            );

            // Base scale from eyes
            let scale = faceEyeDist / maskEyeDist;
            let scaleX = scale;
            let scaleY = scale;

            // If mask has mouth anchors, calculate horizontal stretch for mouth
            if (loadedMask.anchors.leftMouth && loadedMask.anchors.rightMouth) {
                const maskLeftMouth = {
                    x: loadedMask.anchors.leftMouth.x * loadedMask.width,
                    y: loadedMask.anchors.leftMouth.y * loadedMask.height
                };
                const maskRightMouth = {
                    x: loadedMask.anchors.rightMouth.x * loadedMask.width,
                    y: loadedMask.anchors.rightMouth.y * loadedMask.height
                };

                // Calculate mouth widths
                const faceMouthDist = Math.sqrt(
                    Math.pow(rightMouth.x - leftMouth.x, 2) +
                    Math.pow(rightMouth.y - leftMouth.y, 2)
                );
                const maskMouthDist = Math.sqrt(
                    Math.pow(maskRightMouth.x - maskLeftMouth.x, 2) +
                    Math.pow(maskRightMouth.y - maskLeftMouth.y, 2)
                );

                // Calculate mouth-based scale
                const mouthScale = faceMouthDist / maskMouthDist;

                // Blend eye scale for Y (height) and mouth scale for X (width)
                // This stretches the mask horizontally when mouth is wider
                scaleX = (scale + mouthScale) / 2;  // Average for smoother result
                scaleY = scale;  // Keep vertical based on eyes
            }

            // Calculate rotation angles
            const faceAngle = Math.atan2(
                rightEye.y - leftEye.y,
                rightEye.x - leftEye.x
            );
            const maskAngle = Math.atan2(
                maskRightEye.y - maskLeftEye.y,
                maskRightEye.x - maskLeftEye.x
            );
            const rotation = faceAngle - maskAngle;

            // Calculate center points
            const faceCenterX = (leftEye.x + rightEye.x) / 2;
            const faceCenterY = (leftEye.y + rightEye.y) / 2;
            const maskCenterX = (maskLeftEye.x + maskRightEye.x) / 2;
            const maskCenterY = (maskLeftEye.y + maskRightEye.y) / 2;

            // Draw the mask with transformation
            trackCtx.save();

            // Move to face center
            trackCtx.translate(faceCenterX, faceCenterY);

            // Rotate to match face angle
            trackCtx.rotate(rotation);

            // Scale to match face size
            trackCtx.scale(scaleX, scaleY);

            // Draw image centered on anchor midpoint
            trackCtx.drawImage(
                maskImage,
                -maskCenterX,
                -maskCenterY,
                loadedMask.width,
                loadedMask.height
            );

            trackCtx.restore();
        }

        async function loadMaskFile(file) {
            try {
                const text = await file.text();
                const data = JSON.parse(text);

                if (!data.image || !data.anchors || !data.anchors.leftEye || !data.anchors.rightEye) {
                    updateStatus('track', 'Invalid mask file - missing eye anchors');
                    return;
                }

                // Load the image
                const img = new Image();
                img.onload = () => {
                    maskImage = img;
                    loadedMask = {
                        width: data.width,
                        height: data.height,
                        anchors: data.anchors
                    };
                    updateStatus('track', 'Mask loaded!');
                };
                img.onerror = () => {
                    updateStatus('track', 'Error loading mask image');
                };
                img.src = data.image;

            } catch (error) {
                console.error('Error loading mask:', error);
                updateStatus('track', 'Error loading mask file');
            }
        }

        function clearLoadedMask() {
            loadedMask = null;
            maskImage = null;
            updateStatus('track', 'Mask cleared');
        }

        // ============================================
        // EDIT MASK
        // ============================================

        let editCanvas = null;
        let editCtx = null;
        let editAnchors = {};
        let currentEditAnchor = 'leftEye';

        function openEditMask() {
            if (!loadedMask || !maskImage) return;

            // Stop face tracking while editing
            stopTracking();

            // Copy current anchors for editing (eyes only)
            editAnchors = {
                leftEye: loadedMask.anchors.leftEye ? { ...loadedMask.anchors.leftEye } : null,
                rightEye: loadedMask.anchors.rightEye ? { ...loadedMask.anchors.rightEye } : null
            };

            // Setup edit canvas
            editCanvas = document.getElementById('editMaskCanvas');
            editCtx = editCanvas.getContext('2d');
            editCanvas.width = loadedMask.width;
            editCanvas.height = loadedMask.height;

            // Show overlay
            document.getElementById('editMaskOverlay').classList.remove('hidden');

            // Set initial anchor selection
            currentEditAnchor = 'leftEye';
            updateAnchorButtons();
            drawEditMask();
        }

        function closeEditMask() {
            // Stop texture mode if active
            if (textureStream) {
                stopTextureMode();
            }

            // Auto-save anchor changes if both points are set
            if (editAnchors.leftEye && editAnchors.rightEye) {
                loadedMask.anchors = { ...editAnchors };
            }

            document.getElementById('editMaskOverlay').classList.add('hidden');
            // Restart tracking
            if (faceLandmarker) {
                startTracking();
            }
        }

        function drawEditMask() {
            if (!editCtx || !maskImage) return;

            // Draw mask image
            editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height);
            editCtx.drawImage(maskImage, 0, 0);

            // Draw eye anchor points (green)
            if (editAnchors.leftEye) {
                const x = editAnchors.leftEye.x * loadedMask.width;
                const y = editAnchors.leftEye.y * loadedMask.height;
                drawEditMarker(x, y, '#00ff00', 'LE', currentEditAnchor === 'leftEye');
            }
            if (editAnchors.rightEye) {
                const x = editAnchors.rightEye.x * loadedMask.width;
                const y = editAnchors.rightEye.y * loadedMask.height;
                drawEditMarker(x, y, '#00ff00', 'RE', currentEditAnchor === 'rightEye');
            }

            updateEditStatus();
        }

        function drawEditMarker(x, y, color, label, isActive) {
            const radius = Math.max(15, editCanvas.width * 0.02);

            // Outer circle
            editCtx.strokeStyle = isActive ? '#ffff00' : color;
            editCtx.lineWidth = isActive ? 4 : 3;
            editCtx.beginPath();
            editCtx.arc(x, y, radius, 0, Math.PI * 2);
            editCtx.stroke();

            // Inner dot
            editCtx.fillStyle = isActive ? '#ffff00' : color;
            editCtx.beginPath();
            editCtx.arc(x, y, 4, 0, Math.PI * 2);
            editCtx.fill();

            // Label
            editCtx.font = `bold ${radius}px sans-serif`;
            editCtx.fillStyle = isActive ? '#ffff00' : color;
            editCtx.textAlign = 'center';
            editCtx.textBaseline = 'middle';
            editCtx.fillText(label, x, y + radius + 15);
        }

        function updateAnchorButtons() {
            document.querySelectorAll('.anchor-btn').forEach(btn => {
                const anchor = btn.dataset.anchor;
                btn.classList.toggle('active', anchor === currentEditAnchor);
                btn.classList.toggle('placed', editAnchors[anchor] !== null);
            });
        }

        function updateEditStatus() {
            const status = document.getElementById('editStatus');
            const labels = {
                leftEye: 'LEFT eye',
                rightEye: 'RIGHT eye'
            };
            const label = labels[currentEditAnchor] || currentEditAnchor;
            if (editAnchors[currentEditAnchor]) {
                status.textContent = `${label} placed. Tap to reposition or select another point.`;
            } else {
                status.textContent = `Tap on mask to place ${label}`;
            }
        }

        function placeEditAnchor(canvasX, canvasY) {
            // Convert to normalized coordinates
            const normX = canvasX / loadedMask.width;
            const normY = canvasY / loadedMask.height;

            editAnchors[currentEditAnchor] = { x: normX, y: normY };

            updateAnchorButtons();
            drawEditMask();

            // Auto-advance to next unplaced anchor
            const sequence = ['leftEye', 'rightEye'];
            const currentIndex = sequence.indexOf(currentEditAnchor);
            for (let i = currentIndex + 1; i < sequence.length; i++) {
                if (!editAnchors[sequence[i]]) {
                    currentEditAnchor = sequence[i];
                    updateAnchorButtons();
                    updateEditStatus();
                    return;
                }
            }
        }

        function resetEditAnchors() {
            editAnchors = { leftEye: null, rightEye: null };
            currentEditAnchor = 'leftEye';
            updateAnchorButtons();
            drawEditMask();
        }

        function saveEditedMask() {
            if (!editAnchors.leftEye || !editAnchors.rightEye) {
                document.getElementById('editStatus').textContent = 'Please place both eye points before saving';
                return;
            }

            // Update the loaded mask with new anchors
            loadedMask.anchors = { ...editAnchors };

            // Save to file
            const maskData = {
                version: 1,
                image: maskImage.src,
                width: loadedMask.width,
                height: loadedMask.height,
                anchors: editAnchors
            };

            const jsonStr = JSON.stringify(maskData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = 'mask-edited-' + Date.now() + '.json';
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);

            closeEditMask();
            updateStatus('track', 'Mask saved with updated anchor points!');
        }

        async function publishFromEditMask() {
            if (!editAnchors.leftEye || !editAnchors.rightEye) {
                document.getElementById('editStatus').textContent = 'Please place both eye points before publishing';
                return;
            }

            const maskName = generateMaskName();

            document.getElementById('editStatus').textContent = 'Publishing to ' + currentGroup + '...';

            try {
                // Redraw canvas WITHOUT markers before capturing
                editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height);
                editCtx.drawImage(maskImage, 0, 0);

                // Get PNG as base64 data URL
                const imageDataUrl = editCanvas.toDataURL('image/png');

                // Redraw with markers so user can still see them
                drawEditMask();

                // Upload via worker
                const response = await fetch(`${WORKER_URL}/upload`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        group: currentGroup,
                        name: maskName,
                        imageData: imageDataUrl,
                        anchors: editAnchors
                    })
                });

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || 'Upload failed');
                }

                galleryManifest = null;
                document.getElementById('editStatus').textContent = `"${maskName}" published!`;

                // Also update the loaded mask
                loadedMask.anchors = { ...editAnchors };

            } catch (error) {
                console.error('Publish error:', error);
                document.getElementById('editStatus').textContent = 'Publish failed: ' + error.message;
            }
        }

        // ============================================
        // TEXTURE MODE
        // ============================================

        let textureVideo = null;
        let textureStream = null;
        let textureAnimationId = null;
        let maskAlphaData = null;  // Store the mask's alpha channel

        async function startTextureMode() {
            try {
                // Store the mask's alpha channel before we start
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = loadedMask.width;
                tempCanvas.height = loadedMask.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(maskImage, 0, 0);
                maskAlphaData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

                // Start rear camera
                textureStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } },
                    audio: false
                });

                textureVideo = document.getElementById('textureVideo');
                textureVideo.srcObject = textureStream;
                await new Promise(r => textureVideo.onloadedmetadata = r);
                await textureVideo.play();

                // Show texture controls, hide anchor controls
                document.getElementById('anchorControls').classList.add('hidden');
                document.getElementById('textureControls').classList.remove('hidden');

                // Start render loop
                renderTexturePreview();

            } catch (error) {
                console.error('Texture camera error:', error);
                document.getElementById('textureStatus').textContent = 'Camera error: ' + error.message;
            }
        }

        function stopTextureMode() {
            if (textureAnimationId) {
                cancelAnimationFrame(textureAnimationId);
                textureAnimationId = null;
            }
            if (textureStream) {
                textureStream.getTracks().forEach(t => t.stop());
                textureStream = null;
            }
            if (textureVideo) {
                textureVideo.srcObject = null;
            }

            // Show anchor controls, hide texture controls
            document.getElementById('anchorControls').classList.remove('hidden');
            document.getElementById('textureControls').classList.add('hidden');

            // Redraw original mask
            drawEditMask();
        }

        function renderTexturePreview() {
            if (!textureStream || !textureVideo || !editCtx) {
                return;
            }

            const width = editCanvas.width;
            const height = editCanvas.height;

            // Clear canvas
            editCtx.clearRect(0, 0, width, height);

            // Calculate how to fit camera frame into mask dimensions
            const videoAspect = textureVideo.videoWidth / textureVideo.videoHeight;
            const maskAspect = width / height;

            let sx = 0, sy = 0, sw = textureVideo.videoWidth, sh = textureVideo.videoHeight;

            // Crop video to match mask aspect ratio (center crop)
            if (videoAspect > maskAspect) {
                // Video is wider - crop sides
                sw = textureVideo.videoHeight * maskAspect;
                sx = (textureVideo.videoWidth - sw) / 2;
            } else {
                // Video is taller - crop top/bottom
                sh = textureVideo.videoWidth / maskAspect;
                sy = (textureVideo.videoHeight - sh) / 2;
            }

            // Draw camera frame
            editCtx.drawImage(textureVideo, sx, sy, sw, sh, 0, 0, width, height);

            // Apply mask alpha channel
            const frameData = editCtx.getImageData(0, 0, width, height);
            const framePixels = frameData.data;
            const maskPixels = maskAlphaData.data;

            for (let i = 0; i < framePixels.length; i += 4) {
                // Copy alpha from mask to frame
                framePixels[i + 3] = maskPixels[i + 3];
            }

            editCtx.putImageData(frameData, 0, 0);

            textureAnimationId = requestAnimationFrame(renderTexturePreview);
        }

        function captureTexture() {
            if (!textureStream || !editCtx) return;

            // Stop the animation but keep the last frame
            if (textureAnimationId) {
                cancelAnimationFrame(textureAnimationId);
                textureAnimationId = null;
            }

            // The current canvas content is our new texture
            // Create a new image from it
            const newImageUrl = editCanvas.toDataURL('image/png');
            const newImg = new Image();
            newImg.onload = () => {
                // Update the mask image
                maskImage = newImg;

                // Stop camera
                if (textureStream) {
                    textureStream.getTracks().forEach(t => t.stop());
                    textureStream = null;
                }
                if (textureVideo) {
                    textureVideo.srcObject = null;
                }

                // Show anchor controls, hide texture controls
                document.getElementById('anchorControls').classList.remove('hidden');
                document.getElementById('textureControls').classList.add('hidden');

                // Redraw with new texture
                drawEditMask();

                document.getElementById('editStatus').textContent = 'Texture captured! Save to keep changes.';
            };
            newImg.src = newImageUrl;
        }

        // ============================================
        // MASK GALLERY
        // ============================================

        async function openGallery() {
            document.getElementById('galleryOverlay').classList.remove('hidden');
            stopTracking();

            // Always reload manifest to get latest masks
            await loadGalleryManifest();

            renderGallery();
        }

        function closeGallery() {
            document.getElementById('galleryOverlay').classList.add('hidden');
            if (faceLandmarker) {
                startTracking();
            }
        }

        async function loadGalleryManifest() {
            try {
                // Local masks are stored in localStorage
                if (currentGroup === 'local') {
                    const localMasks = JSON.parse(localStorage.getItem('local_masks') || '[]');
                    galleryManifest = { masks: localMasks, group: 'local', name: 'Local-masks' };
                    currentGroupName = 'Local-masks';
                    currentGroupType = 'local';
                    console.log('Loaded ' + localMasks.length + ' local masks');
                } else {
                    let url = `${WORKER_URL}/masks?group=${currentGroup}`;
                    url = withAdmin(url);
                    url = withToken(url, currentGroup);

                    const response = await fetch(url, { cache: 'no-store' });
                    galleryManifest = await response.json();

                    // Update group info from response
                    if (galleryManifest.name) {
                        currentGroupName = galleryManifest.name + '-masks';
                        // Store group name for later use in group picker (without -masks suffix)
                        const groupNames = JSON.parse(localStorage.getItem('group_names') || '{}');
                        groupNames[currentGroup] = galleryManifest.name;
                        localStorage.setItem('group_names', JSON.stringify(groupNames));
                    }
                    if (galleryManifest.type) {
                        currentGroupType = galleryManifest.type;
                    }
                    updateHeader();

                    console.log('Loaded ' + galleryManifest.masks.length + ' masks for group: ' + currentGroup + ' (' + currentGroupName + ')');
                }

                // Update group name display in gallery
                const groupNameEl = document.getElementById('groupName');
                if (groupNameEl) groupNameEl.textContent = currentGroupName;
            } catch (error) {
                console.error('Failed to load gallery manifest:', error);
                galleryManifest = { masks: [] };
            }
        }

        function renderGallery() {
            const grid = document.getElementById('galleryGrid');
            const countEl = document.getElementById('maskCount');

            if (!galleryManifest || galleryManifest.masks.length === 0) {
                grid.innerHTML = '<div class="gallery-empty">No masks in this group yet.<br>Create one and tap "Save"!</div>';
                countEl.textContent = '(0)';
                return;
            }

            countEl.textContent = '(' + galleryManifest.masks.length + ')';
            grid.innerHTML = '';

            // Only show edit/delete if user can modify this group
            // Admin can edit anything, local is always editable, friend groups need token
            const friendTokens = JSON.parse(localStorage.getItem('friend_tokens') || '{}');
            const canEdit = isAdmin || currentGroup === 'local' || friendTokens[currentGroup];

            galleryManifest.masks.forEach(mask => {
                const item = document.createElement('div');
                item.className = 'gallery-mask-item';
                // Local masks have data URLs, remote masks need GitHub URL
                const imageUrl = mask.image.startsWith('data:')
                    ? mask.image
                    : `https://raw.githubusercontent.com/DurrellBishop-iCloud/m/main/${mask.image}`;

                if (canEdit) {
                    item.innerHTML = `
                        <img src="${imageUrl}" alt="${mask.name}">
                        <button class="edit-btn">Edit</button>
                        <button class="delete-btn" data-mask-id="${mask.id}">&times;</button>
                    `;
                } else {
                    item.innerHTML = `
                        <img src="${imageUrl}" alt="${mask.name}">
                    `;
                }

                // Click on image selects the mask
                item.querySelector('img').addEventListener('click', () => selectGalleryMask(mask));

                if (canEdit) {
                    // Click on edit button opens mask for editing
                    item.querySelector('.edit-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        editMaskFromGallery(mask, imageUrl);
                    });

                    // Click on delete button deletes the mask
                    item.querySelector('.delete-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        deleteMask(mask);
                    });
                }

                grid.appendChild(item);
            });
        }

        // Track mask being edited
        let editingMask = null;
        let editingMaskGroup = null;

        // Edit a mask from the gallery
        async function editMaskFromGallery(mask, imageUrl) {
            editingMask = mask;
            editingMaskGroup = currentGroup;
            isEditingExistingMask = true;

            closeGallery();

            // Stop any running camera
            stopCaptureCamera();

            // Load the image into preview canvas
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                // Switch to capture view (camera won't start due to isEditingExistingMask flag)
                switchView('capture', true);

                // Downsample if needed, calculate scale factor
                let width = img.width;
                let height = img.height;
                let scale = 1;

                if (width > MAX_IMAGE_SIZE || height > MAX_IMAGE_SIZE) {
                    if (width > height) {
                        scale = MAX_IMAGE_SIZE / width;
                        height = Math.round(height * scale);
                        width = MAX_IMAGE_SIZE;
                    } else {
                        scale = MAX_IMAGE_SIZE / height;
                        width = Math.round(width * scale);
                        height = MAX_IMAGE_SIZE;
                    }
                }

                // Set up preview canvas
                previewCanvas = document.getElementById('previewCanvas');
                previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });
                previewCanvas.width = width;
                previewCanvas.height = height;
                previewCtx.drawImage(img, 0, 0, width, height);

                // Save current state
                currentMaskData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);

                // Load anchors as eye points (scaled to new dimensions)
                eyePoints = { left: null, right: null };
                if (mask.anchors) {
                    if (mask.anchors.leftEye) {
                        eyePoints.left = {
                            x: mask.anchors.leftEye.x * width,
                            y: mask.anchors.leftEye.y * height
                        };
                    }
                    if (mask.anchors.rightEye) {
                        eyePoints.right = {
                            x: mask.anchors.rightEye.x * width,
                            y: mask.anchors.rightEye.y * height
                        };
                    }
                }

                // Hide camera, show preview with mask
                document.getElementById('captureCamera').classList.add('hidden');
                document.getElementById('capturePreview').classList.remove('hidden');
                document.getElementById('captureControls').classList.add('hidden');
                document.getElementById('editControls').classList.remove('hidden');
                document.getElementById('editHelpText').classList.remove('hidden');
                // document.getElementById('eyeControls').classList.remove('hidden');

                // Change Retake button to Cancel when editing
                document.getElementById('retakeBtn').textContent = 'Cancel';

                // Draw markers
                drawEyePointMarkers();

                const sizeNote = scale < 1 ? ` (downsampled to ${width}x${height})` : '';
                updateStatus('capture', `Editing mask${sizeNote} - tap to adjust anchors, then Save`);
            };
            img.src = imageUrl;
        }

        async function deleteMask(mask) {
            // Confirm deletion
            if (!confirm(`Delete "${mask.name}"?\n\nThis will permanently remove the mask.`)) {
                return;
            }

            try {
                // Show deleting status
                const countEl = document.getElementById('maskCount');
                countEl.textContent = '(deleting...)';

                if (currentGroup === 'local') {
                    // Delete from localStorage
                    const localMasks = JSON.parse(localStorage.getItem('local_masks') || '[]');
                    const filtered = localMasks.filter(m => m.id !== mask.id);
                    localStorage.setItem('local_masks', JSON.stringify(filtered));
                } else {
                    // Delete via worker
                    const response = await fetch(withAdmin(`${WORKER_URL}/mask`), {
                        method: 'DELETE',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            group: currentGroup,
                            maskId: mask.id
                        })
                    });

                    const result = await response.json();
                    if (!response.ok) {
                        throw new Error(result.error || 'Delete failed');
                    }
                }

                // Reload gallery
                await loadGalleryManifest();
                renderGallery();

            } catch (error) {
                console.error('Failed to delete mask:', error);
                alert('Failed to delete mask: ' + error.message);
                renderGallery();
            }
        }

        async function selectGalleryMask(maskData) {
            return new Promise((resolve, reject) => {
                try {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';

                    img.onload = () => {
                        maskImage = img;
                        loadedMask = {
                            width: img.width,
                            height: img.height,
                            anchors: maskData.anchors
                        };
                        loadedMaskId = maskData.id || null;

                        // Only close gallery if it's open
                        if (!document.getElementById('galleryOverlay').classList.contains('hidden')) {
                            closeGallery();
                        }

                        resolve();
                    };

                    img.onerror = (err) => {
                        debug('IMG ERROR: ' + maskData.image);
                        reject(err);
                    };

                    // Local masks have data URLs, remote masks need GitHub URL
                    img.src = maskData.image.startsWith('data:')
                        ? maskData.image
                        : `https://raw.githubusercontent.com/DurrellBishop-iCloud/m/main/${maskData.image}`;

                } catch (error) {
                    debug('CATCH ERROR: ' + error.message);
                    reject(error);
                }
            });
        }

        // Reload current mask after editing (fetches fresh data)
        async function reloadCurrentMask() {
            // Clear current mask
            loadedMask = null;
            loadedMaskId = null;
            maskImage = null;

            // Reload gallery manifest
            await loadGalleryManifest();

            // If we have masks, load the first one (or current index if valid)
            if (galleryManifest && galleryManifest.masks && galleryManifest.masks.length > 0) {
                if (currentMaskIndex >= galleryManifest.masks.length) {
                    currentMaskIndex = 0;
                }
                await selectGalleryMask(galleryManifest.masks[currentMaskIndex]);
            }
        }

        // ============================================
        // PUBLISH TO GALLERY (Direct to GitHub)
        // ============================================

        function getGitHubToken() {
            let token = localStorage.getItem('github_token');
            if (!token) {
                token = prompt(
                    'Enter your GitHub Personal Access Token:\n\n' +
                    '(Create one at github.com â†’ Settings â†’ Developer settings â†’ Personal access tokens â†’ Tokens (classic) â†’ Generate new token â†’ Select "repo" scope)'
                );
                if (token) {
                    localStorage.setItem('github_token', token);
                }
            }
            return token;
        }

        async function publishToGallery() {
            if (!eyePoints.left || !eyePoints.right) {
                updateStatus('capture', 'Please add eye points before publishing');
                return;
            }

            const maskName = generateMaskName();

            updateStatus('capture', 'Publishing to group: ' + currentGroup + '...');

            try {
                // Redraw canvas with stroke if enabled, WITHOUT markers
                drawMaskForSave();

                // Get PNG as base64 data URL
                const imageDataUrl = previewCanvas.toDataURL('image/png');

                // Create anchors (eyes only)
                const anchors = {
                    leftEye: {
                        x: eyePoints.left.x / previewCanvas.width,
                        y: eyePoints.left.y / previewCanvas.height
                    },
                    rightEye: {
                        x: eyePoints.right.x / previewCanvas.width,
                        y: eyePoints.right.y / previewCanvas.height
                    }
                };

                // Upload via worker
                const response = await fetch(`${WORKER_URL}/upload`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        group: currentGroup,
                        name: maskName,
                        imageData: imageDataUrl,
                        anchors: anchors
                    })
                });

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || 'Upload failed');
                }

                // Redraw markers
                drawEyePointMarkers();

                // Clear the gallery cache so it reloads
                galleryManifest = null;

                updateStatus('capture', `"${maskName}" published to ${currentGroup}!`);

            } catch (error) {
                console.error('Publish error:', error);
                drawEyePointMarkers();
                updateStatus('capture', 'Publish failed: ' + error.message);
            }
        }

        // ============================================
        // CREATE MASK TEXTURE MODE
        // ============================================

        let createTextureStream = null;
        let createTextureVideo = null;
        let createTextureAnimationId = null;
        let createMaskAlphaData = null;

        async function startCreateTextureMode() {
            if (!currentMaskData) return;

            try {
                // Store the mask's alpha channel
                createMaskAlphaData = new ImageData(
                    new Uint8ClampedArray(currentMaskData.data),
                    currentMaskData.width,
                    currentMaskData.height
                );

                // Start rear camera
                createTextureStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } },
                    audio: false
                });

                createTextureVideo = document.createElement('video');
                createTextureVideo.srcObject = createTextureStream;
                createTextureVideo.setAttribute('playsinline', '');
                await new Promise(r => createTextureVideo.onloadedmetadata = r);
                await createTextureVideo.play();

                // Update UI
                document.getElementById('editControls').classList.add('hidden');
                document.getElementById('editHelpText').classList.add('hidden');
                document.getElementById('eyeControls').classList.add('hidden');
                exitEyePointMode();
                document.getElementById('toleranceRow').classList.add('hidden');

                // Show texture controls at top
                document.getElementById('createTextureControls').classList.remove('hidden');

                updateStatus('capture', 'Point camera at texture and tap Capture');

                renderCreateTexturePreview();

            } catch (error) {
                console.error('Texture camera error:', error);
                updateStatus('capture', 'Camera error: ' + error.message);
            }
        }

        function stopCreateTextureMode() {
            if (createTextureAnimationId) {
                cancelAnimationFrame(createTextureAnimationId);
                createTextureAnimationId = null;
            }
            if (createTextureStream) {
                createTextureStream.getTracks().forEach(t => t.stop());
                createTextureStream = null;
            }
            createTextureVideo = null;

            // Restore UI
            document.getElementById('createTextureControls').classList.add('hidden');
            document.getElementById('editControls').classList.remove('hidden');
            document.getElementById('editHelpText').classList.remove('hidden');
            // document.getElementById('eyeControls').classList.remove('hidden');
            document.getElementById('toleranceRow').classList.remove('hidden');

            // Redraw mask
            if (currentMaskData) {
                previewCtx.putImageData(currentMaskData, 0, 0);
                drawEyePointMarkers();
            }

            updateStatus('capture', 'Texture cancelled');
        }

        function renderCreateTexturePreview() {
            if (!createTextureStream || !createTextureVideo || !previewCtx) return;

            const width = previewCanvas.width;
            const height = previewCanvas.height;

            previewCtx.clearRect(0, 0, width, height);

            const videoAspect = createTextureVideo.videoWidth / createTextureVideo.videoHeight;
            const maskAspect = width / height;

            let sx = 0, sy = 0, sw = createTextureVideo.videoWidth, sh = createTextureVideo.videoHeight;

            if (videoAspect > maskAspect) {
                sw = createTextureVideo.videoHeight * maskAspect;
                sx = (createTextureVideo.videoWidth - sw) / 2;
            } else {
                sh = createTextureVideo.videoWidth / maskAspect;
                sy = (createTextureVideo.videoHeight - sh) / 2;
            }

            previewCtx.drawImage(createTextureVideo, sx, sy, sw, sh, 0, 0, width, height);

            const frameData = previewCtx.getImageData(0, 0, width, height);
            const framePixels = frameData.data;
            const maskPixels = createMaskAlphaData.data;

            for (let i = 0; i < framePixels.length; i += 4) {
                framePixels[i + 3] = maskPixels[i + 3];
            }

            previewCtx.putImageData(frameData, 0, 0);

            createTextureAnimationId = requestAnimationFrame(renderCreateTexturePreview);
        }

        function captureCreateTexture() {
            if (createTextureAnimationId) {
                cancelAnimationFrame(createTextureAnimationId);
                createTextureAnimationId = null;
            }

            // Save current canvas as new mask data
            currentMaskData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);

            // Stop camera
            if (createTextureStream) {
                createTextureStream.getTracks().forEach(t => t.stop());
                createTextureStream = null;
            }
            createTextureVideo = null;

            // Restore UI
            document.getElementById('createTextureControls').classList.add('hidden');
            document.getElementById('editControls').classList.remove('hidden');
            document.getElementById('editHelpText').classList.remove('hidden');
            // document.getElementById('eyeControls').classList.remove('hidden');
            document.getElementById('toleranceRow').classList.remove('hidden');

            // Redraw with markers
            drawEyePointMarkers();

            updateStatus('capture', 'Texture captured! Add eye points and save.');
        }

        async function uploadToGitHub(token, path, contentBase64, message, sha = null) {
            const body = {
                message: message,
                content: contentBase64,
                branch: GITHUB_BRANCH
            };

            if (sha) {
                body.sha = sha;
            }

            const response = await fetch(
                `https://api.github.com/repos/${GITHUB_REPO}/contents/${path}`,
                {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${token}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(body)
                }
            );

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.message || response.status);
            }

            return response.json();
        }

        // ============================================
        // CAPTURE / CREATE MASK
        // ============================================

        async function startCaptureCamera() {
            try {
                updateStatus('capture', 'Starting camera...');

                captureStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } },
                    audio: false
                });

                captureVideo = document.getElementById('captureVideo');
                captureVideo.srcObject = captureStream;
                await new Promise(r => captureVideo.onloadedmetadata = r);
                await captureVideo.play();

                // Show camera, hide preview
                document.getElementById('captureCamera').classList.remove('hidden');
                document.getElementById('capturePreview').classList.add('hidden');
                document.getElementById('captureControls').classList.remove('hidden');
                document.getElementById('editControls').classList.add('hidden');
                document.getElementById('editHelpText').classList.add('hidden');
                document.getElementById('eyeControls').classList.add('hidden');
                document.getElementById('toleranceRow').classList.add('hidden');

                updateStatus('capture', 'Point camera at your drawing and tap "Take Photo"');
            } catch (error) {
                console.error('Capture camera error:', error);
                updateStatus('capture', 'Camera error: ' + error.message);
            }
        }

        function stopCaptureCamera() {
            if (captureStream) {
                captureStream.getTracks().forEach(t => t.stop());
                captureStream = null;
            }
            if (captureVideo) {
                captureVideo.srcObject = null;
            }
        }

        // Downsample image to max 1024px on longest side
        const MAX_IMAGE_SIZE = 1024;
        function downsampleToCanvas(source, srcWidth, srcHeight) {
            let width = srcWidth;
            let height = srcHeight;

            // Scale down if needed
            if (width > MAX_IMAGE_SIZE || height > MAX_IMAGE_SIZE) {
                if (width > height) {
                    height = Math.round(height * (MAX_IMAGE_SIZE / width));
                    width = MAX_IMAGE_SIZE;
                } else {
                    width = Math.round(width * (MAX_IMAGE_SIZE / height));
                    height = MAX_IMAGE_SIZE;
                }
            }

            const canvas = document.getElementById('previewCanvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(source, 0, 0, width, height);

            return { canvas, ctx, width, height };
        }

        function takePhoto() {
            if (!captureVideo) return;

            // Downsample to max 1024px
            const result = downsampleToCanvas(captureVideo, captureVideo.videoWidth, captureVideo.videoHeight);
            previewCanvas = result.canvas;
            previewCtx = result.ctx;

            // Store original image data
            originalImageData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);

            // Analyze paper color from edges
            analyzePaper();

            // Stop camera
            stopCaptureCamera();

            // Show preview, hide camera
            document.getElementById('captureCamera').classList.add('hidden');
            document.getElementById('capturePreview').classList.remove('hidden');
            document.getElementById('captureControls').classList.add('hidden');
            document.getElementById('editControls').classList.remove('hidden');
            document.getElementById('editHelpText').classList.remove('hidden');
            // document.getElementById('eyeControls').classList.remove('hidden');
            document.getElementById('toleranceRow').classList.remove('hidden');

            // Run initial background removal
            removeBackground();

            // Auto-place eye points at sensible defaults (can be adjusted later via gestures)
            // Left/right swapped because camera view is mirrored
            eyePoints = {
                left: { x: previewCanvas.width * 0.65, y: previewCanvas.height * 0.38 },
                right: { x: previewCanvas.width * 0.35, y: previewCanvas.height * 0.38 }
            };

            updateStatus('capture', 'Adjust cutout then Save');
        }

        function loadPictureFromFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            const img = new Image();
            img.onload = () => {
                // Downsample to max 1024px
                const result = downsampleToCanvas(img, img.width, img.height);
                previewCanvas = result.canvas;
                previewCtx = result.ctx;

                // Store original image data
                originalImageData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);

                // Analyze paper color from edges
                analyzePaper();

                // Stop camera if running
                stopCaptureCamera();

                // Show preview, hide camera
                document.getElementById('captureCamera').classList.add('hidden');
                document.getElementById('capturePreview').classList.remove('hidden');
                document.getElementById('captureControls').classList.add('hidden');
                document.getElementById('editControls').classList.remove('hidden');
                document.getElementById('editHelpText').classList.remove('hidden');
                // document.getElementById('eyeControls').classList.remove('hidden');
                document.getElementById('toleranceRow').classList.remove('hidden');

                // Run initial background removal
                removeBackground();

                // Auto-place eye points at sensible defaults (can be adjusted later via gestures)
                // Left/right swapped because camera view is mirrored
                eyePoints = {
                    left: { x: previewCanvas.width * 0.65, y: previewCanvas.height * 0.38 },
                    right: { x: previewCanvas.width * 0.35, y: previewCanvas.height * 0.38 }
                };

                updateStatus('capture', 'Adjust cutout then Save');
            };

            img.onerror = () => {
                alert('Failed to load image');
            };

            img.src = URL.createObjectURL(file);

            // Clear input so same file can be selected again
            e.target.value = '';
        }

        function retakePhoto() {
            // If editing existing mask, Cancel returns to track view
            if (isEditingExistingMask) {
                isEditingExistingMask = false;
                editingMask = null;
                editingMaskGroup = null;
                document.getElementById('retakeBtn').textContent = 'Retake';
                switchView('track');
                return;
            }

            originalImageData = null;
            currentMaskData = null;
            eyePoints = { left: null, right: null };
            exitEyePointMode();
            startCaptureCamera();
        }

        // Cached paper color (computed once when photo taken)
        let paperColor = null;

        function analyzePaper() {
            const width = originalImageData.width;
            const height = originalImageData.height;
            const srcData = originalImageData.data;

            // Sample ALL edge pixels
            let avgR = 0, avgG = 0, avgB = 0;
            let count = 0;

            // Top and bottom rows
            for (let x = 0; x < width; x++) {
                let idx = x * 4;
                avgR += srcData[idx]; avgG += srcData[idx + 1]; avgB += srcData[idx + 2]; count++;
                idx = ((height - 1) * width + x) * 4;
                avgR += srcData[idx]; avgG += srcData[idx + 1]; avgB += srcData[idx + 2]; count++;
            }
            // Left and right columns
            for (let y = 1; y < height - 1; y++) {
                let idx = (y * width) * 4;
                avgR += srcData[idx]; avgG += srcData[idx + 1]; avgB += srcData[idx + 2]; count++;
                idx = (y * width + width - 1) * 4;
                avgR += srcData[idx]; avgG += srcData[idx + 1]; avgB += srcData[idx + 2]; count++;
            }

            paperColor = {
                r: Math.round(avgR / count),
                g: Math.round(avgG / count),
                b: Math.round(avgB / count)
            };
        }

        function removeBackground() {
            if (!originalImageData || !paperColor) return;

            const tolerance = parseInt(document.getElementById('toleranceSlider').value);
            const width = originalImageData.width;
            const height = originalImageData.height;

            // Do flood fill
            const result = doFloodFillWithTolerance(
                originalImageData.data, width, height,
                paperColor.r, paperColor.g, paperColor.b, tolerance
            );

            const data = result.imageData.data;

            // Sort blobs by size and keep only the biggest
            const sortedBlobs = result.blobs.slice().sort((a, b) => b.size - a.size);
            const biggestBlob = sortedBlobs[0];

            // Remove all blobs except the biggest
            let removed = 0;
            result.blobs.forEach(blob => {
                if (blob !== biggestBlob) {
                    blob.pixelIndices.forEach(idx => {
                        data[idx * 4 + 3] = 0;
                    });
                    removed++;
                }
            });

            previewCtx.putImageData(result.imageData, 0, 0);

            // Save current state for later use (eye point markers)
            currentMaskData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);

            const blobSize = biggestBlob ? biggestBlob.size : 0;
            updateStatus('capture', `Kept largest blob (${blobSize} pixels), removed ${removed} others. Tap inside to cut holes.`);
        }

        function cutHoleAtPoint(canvasX, canvasY) {
            if (!previewCanvas || !previewCtx) return;

            // Restore clean image first (remove any markers)
            if (currentMaskData) {
                previewCtx.putImageData(currentMaskData, 0, 0);
            }

            const tolerance = parseInt(document.getElementById('toleranceSlider').value);
            const imageData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);
            const data = imageData.data;
            const width = previewCanvas.width;
            const height = previewCanvas.height;

            const startIdx = Math.floor(canvasY) * width + Math.floor(canvasX);
            if (startIdx < 0 || startIdx >= width * height) return;

            // Get the color at tap point
            const tapR = data[startIdx * 4];
            const tapG = data[startIdx * 4 + 1];
            const tapB = data[startIdx * 4 + 2];
            const tapA = data[startIdx * 4 + 3];

            if (tapA === 0) {
                updateStatus('capture', 'Tap on a visible area to cut a hole');
                return;
            }

            // Flood fill from tap point, only filling pixels similar to tapped color
            const visited = new Uint8Array(width * height);
            const queue = [startIdx];
            let head = 0;
            let filledCount = 0;

            while (head < queue.length) {
                const idx = queue[head++];
                if (visited[idx]) continue;
                visited[idx] = 1;

                // Skip transparent pixels
                if (data[idx * 4 + 3] === 0) continue;

                // Check color similarity to tapped color
                const r = data[idx * 4];
                const g = data[idx * 4 + 1];
                const b = data[idx * 4 + 2];

                if (colorDistance(r, g, b, tapR, tapG, tapB) > tolerance) continue;

                // Make transparent
                data[idx * 4 + 3] = 0;
                filledCount++;

                const x = idx % width;
                const y = Math.floor(idx / width);

                // Add neighbors
                if (x > 0) queue.push(idx - 1);
                if (x < width - 1) queue.push(idx + 1);
                if (y > 0) queue.push(idx - width);
                if (y < height - 1) queue.push(idx + width);
            }

            previewCtx.putImageData(imageData, 0, 0);

            // Save current state (clean, without markers)
            currentMaskData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);

            // Redraw markers for display
            drawEyePointMarkers();

            updateStatus('capture', `Cut hole (${filledCount} pixels). Tap again or Save.`);
        }

        function doFloodFillWithTolerance(srcData, width, height, avgR, avgG, avgB, tolerance) {
            const imageData = new ImageData(
                new Uint8ClampedArray(srcData),
                width,
                height
            );
            const data = imageData.data;

            const visited = new Uint8Array(width * height);
            const queue = [];
            let head = 0;

            // Add all edge pixels to queue
            for (let x = 0; x < width; x++) {
                queue.push(x);
                queue.push((height - 1) * width + x);
            }
            for (let y = 1; y < height - 1; y++) {
                queue.push(y * width);
                queue.push(y * width + width - 1);
            }

            // Flood fill
            let removedCount = 0;
            while (head < queue.length) {
                const idx = queue[head++];
                if (visited[idx]) continue;
                visited[idx] = 1;

                const x = idx % width;
                const y = Math.floor(idx / width);

                const pixelIdx = idx * 4;
                const r = data[pixelIdx];
                const g = data[pixelIdx + 1];
                const b = data[pixelIdx + 2];

                if (colorDistance(r, g, b, avgR, avgG, avgB) <= tolerance) {
                    data[pixelIdx + 3] = 0;
                    removedCount++;

                    if (x > 0 && !visited[idx - 1]) queue.push(idx - 1);
                    if (x < width - 1 && !visited[idx + 1]) queue.push(idx + 1);
                    if (y > 0 && !visited[idx - width]) queue.push(idx - width);
                    if (y < height - 1 && !visited[idx + width]) queue.push(idx + width);
                }
            }

            const opaqueCount = (width * height) - removedCount;

            // Count connected blobs of opaque pixels
            const blobInfo = countBlobs(data, width, height);

            return { imageData, opaqueCount, removedCount, blobCount: blobInfo.count, blobs: blobInfo.blobs };
        }

        function countBlobs(data, width, height) {
            const visited = new Uint8Array(width * height);
            const blobMap = new Int32Array(width * height); // Which blob each pixel belongs to (-1 = none)
            blobMap.fill(-1);
            const blobs = [];
            let blobCount = 0;

            // Colors for visualizing blobs
            const blobColors = [
                [255, 0, 0],     // red
                [0, 255, 0],     // green
                [0, 0, 255],     // blue
                [255, 255, 0],   // yellow
                [255, 0, 255],   // magenta
                [0, 255, 255],   // cyan
                [255, 128, 0],   // orange
                [128, 0, 255],   // purple
                [0, 255, 128],   // spring green
                [255, 0, 128],   // pink
            ];

            for (let startIdx = 0; startIdx < width * height; startIdx++) {
                if (visited[startIdx]) continue;
                if (data[startIdx * 4 + 3] === 0) {
                    visited[startIdx] = 1;
                    continue;
                }

                // Found a new blob
                const blobId = blobCount;
                blobCount++;
                let blobSize = 0;
                let minX = width, minY = height, maxX = 0, maxY = 0;
                let touchesEdge = false;
                const pixelIndices = [];

                const queue = [startIdx];
                let head = 0;

                while (head < queue.length) {
                    const idx = queue[head++];
                    if (visited[idx]) continue;
                    visited[idx] = 1;

                    if (data[idx * 4 + 3] === 0) continue;

                    blobSize++;
                    blobMap[idx] = blobId;
                    pixelIndices.push(idx);

                    const x = idx % width;
                    const y = Math.floor(idx / width);

                    // Check if touches edge
                    if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {
                        touchesEdge = true;
                    }

                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;

                    if (x > 0 && !visited[idx - 1]) queue.push(idx - 1);
                    if (x < width - 1 && !visited[idx + 1]) queue.push(idx + 1);
                    if (y > 0 && !visited[idx - width]) queue.push(idx - width);
                    if (y < height - 1 && !visited[idx + width]) queue.push(idx + width);
                }

                blobs.push({
                    id: blobId,
                    size: blobSize,
                    touchesEdge,
                    pixelIndices,
                    bounds: { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY },
                    color: blobColors[blobId % blobColors.length]
                });
            }

            // Sort blobs by size (largest first)
            blobs.sort((a, b) => b.size - a.size);

            return { count: blobCount, blobs, blobMap };
        }

        function colorizeBlobs(data, blobs) {
            // Color each blob with its assigned color (for visualization)
            blobs.forEach(blob => {
                const [r, g, b] = blob.color;
                blob.pixelIndices.forEach(idx => {
                    data[idx * 4] = r;
                    data[idx * 4 + 1] = g;
                    data[idx * 4 + 2] = b;
                });
            });
        }

        function removeEdgeBlobs(data, blobs) {
            // Remove any blob that touches the edge
            let removedCount = 0;
            blobs.forEach(blob => {
                if (blob.touchesEdge) {
                    blob.pixelIndices.forEach(idx => {
                        data[idx * 4 + 3] = 0; // Make transparent
                    });
                    removedCount++;
                }
            });
            return removedCount;
        }

        function sampleBackgroundColor(data, width, height) {
            // Sample from corners
            const samples = [];
            const cornerSize = Math.min(20, Math.floor(width / 10), Math.floor(height / 10));

            // Top-left corner
            for (let y = 0; y < cornerSize; y++) {
                for (let x = 0; x < cornerSize; x++) {
                    const idx = (y * width + x) * 4;
                    samples.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
            }

            // Top-right corner
            for (let y = 0; y < cornerSize; y++) {
                for (let x = width - cornerSize; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    samples.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
            }

            // Bottom-left corner
            for (let y = height - cornerSize; y < height; y++) {
                for (let x = 0; x < cornerSize; x++) {
                    const idx = (y * width + x) * 4;
                    samples.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
            }

            // Bottom-right corner
            for (let y = height - cornerSize; y < height; y++) {
                for (let x = width - cornerSize; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    samples.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
            }

            // Average the samples
            const avg = { r: 0, g: 0, b: 0 };
            samples.forEach(s => {
                avg.r += s.r;
                avg.g += s.g;
                avg.b += s.b;
            });
            avg.r = Math.round(avg.r / samples.length);
            avg.g = Math.round(avg.g / samples.length);
            avg.b = Math.round(avg.b / samples.length);

            return avg;
        }

        function colorDistance(r1, g1, b1, r2, g2, b2) {
            // Simple Euclidean distance in RGB space
            return Math.sqrt(
                Math.pow(r1 - r2, 2) +
                Math.pow(g1 - g2, 2) +
                Math.pow(b1 - b2, 2)
            );
        }

        function saveMask() {
            // Redraw canvas with stroke if enabled, WITHOUT markers
            drawMaskForSave();

            // Convert canvas to data URL (clean, no markers)
            const dataUrl = previewCanvas.toDataURL('image/png');

            // Create mask data object with image and anchor points
            const maskData = {
                version: 1,
                image: dataUrl,
                width: previewCanvas.width,
                height: previewCanvas.height,
                anchors: {}
            };

            // Add eye points if they exist (normalized 0-1 coordinates)
            if (eyePoints.left) {
                maskData.anchors.leftEye = {
                    x: eyePoints.left.x / previewCanvas.width,
                    y: eyePoints.left.y / previewCanvas.height
                };
            }
            if (eyePoints.right) {
                maskData.anchors.rightEye = {
                    x: eyePoints.right.x / previewCanvas.width,
                    y: eyePoints.right.y / previewCanvas.height
                };
            }

            // Download as JSON file
            const jsonStr = JSON.stringify(maskData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = 'mask-' + Date.now() + '.json';
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);

            // Redraw markers for continued editing
            drawEyePointMarkers();

            const hasEyes = eyePoints.left && eyePoints.right;
            updateStatus('capture', hasEyes ? 'Mask saved with eye anchors!' : 'Mask saved!');
        }

        // ============================================
        // EYE POINT PLACEMENT
        // ============================================

        function startPlacingEye(which) {
            if (eraseMode) exitEraseMode();
            eyePointMode = true;
            placingEye = which;
            // Clear the existing anchor for this eye
            if (which === 'right') {
                eyePoints.right = null;
            } else {
                eyePoints.left = null;
            }
            drawEyePointMarkers();
            document.getElementById('eyeRightBtn').classList.toggle('active', which === 'right');
            document.getElementById('eyeLeftBtn').classList.toggle('active', which === 'left');
            updateStatus('capture', `Tap on mask to place ${which === 'right' ? 'LEFT' : 'RIGHT'} eye location`);
        }

        function exitEyePointMode() {
            eyePointMode = false;
            placingEye = null;
            document.getElementById('eyeRightBtn').classList.remove('active');
            document.getElementById('eyeLeftBtn').classList.remove('active');
        }

        // ============================================
        // ERASE MODE
        // ============================================

        function enterEraseMode() {
            eraseMode = true;
            exitEyePointMode(); // Exit eye point mode if active
            document.getElementById('eraseBtn').classList.add('active');
            document.getElementById('previewCanvas').classList.add('erase-mode');
            // Restore clean image (remove markers) before erasing
            if (currentMaskData && previewCtx) {
                previewCtx.putImageData(currentMaskData, 0, 0);
            }

            // Switch slider to eraser size
            savedToleranceValue = parseInt(document.getElementById('toleranceSlider').value);
            document.querySelector('#toleranceRow label').textContent = 'Size:';
            const slider = document.getElementById('toleranceSlider');
            slider.min = 10;
            slider.max = 100;
            slider.value = eraserSize;
            document.getElementById('toleranceValue').textContent = eraserSize;
            document.getElementById('toleranceRow').classList.remove('hidden');

            updateStatus('capture', 'Drag finger to erase. Tap Erase again to exit.');
        }

        function exitEraseMode() {
            eraseMode = false;
            isErasing = false;
            document.getElementById('eraseBtn').classList.remove('active');
            document.getElementById('previewCanvas').classList.remove('erase-mode');
            // Save the current state after erasing (without markers)
            if (previewCtx && previewCanvas) {
                currentMaskData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);
            }
            // Redraw markers on top
            drawEyePointMarkers();

            // Restore slider to tolerance
            document.querySelector('#toleranceRow label').textContent = 'Tolerance:';
            const slider = document.getElementById('toleranceSlider');
            slider.min = 10;
            slider.max = 150;
            slider.value = savedToleranceValue;
            document.getElementById('toleranceValue').textContent = savedToleranceValue;

            updateStatus('capture', 'Erase complete');
        }

        function getCanvasCoords(e, canvas) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function eraseAtPoint(x, y) {
            if (!previewCtx) return;

            // Use destination-out to erase (make transparent)
            previewCtx.save();
            previewCtx.globalCompositeOperation = 'destination-out';
            previewCtx.beginPath();
            previewCtx.arc(x, y, eraserSize, 0, Math.PI * 2);
            previewCtx.fill();
            previewCtx.restore();
        }

        function clearEyePoints() {
            eyePoints = { left: null, right: null };
            exitEyePointMode();
            drawEyePointMarkers();
        }

        function placeEyePoint(canvasX, canvasY) {
            if (placingEye === 'right') {
                eyePoints.right = { x: canvasX, y: canvasY };
            } else if (placingEye === 'left') {
                eyePoints.left = { x: canvasX, y: canvasY };
            }
            drawEyePointMarkers();
            exitEyePointMode();

            if (eyePoints.left && eyePoints.right) {
                updateStatus('capture', 'Both eyes placed! Ready to Save.');
            } else {
                updateStatus('capture', 'Place the other eye location.');
            }
        }

        function drawEyePointMarkers() {
            if (!previewCanvas || !previewCtx || !currentMaskData) return;

            // Clear canvas
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

            // Create temp canvas with mask for drawing
            const maskCanvas = document.createElement('canvas');
            maskCanvas.width = previewCanvas.width;
            maskCanvas.height = previewCanvas.height;
            const maskCtx = maskCanvas.getContext('2d');
            maskCtx.putImageData(currentMaskData, 0, 0);

            // Draw stroke effect if enabled (draw BEFORE the mask so it appears behind)
            if (strokeEnabled) {
                drawStrokeEffect(maskCanvas);
            }

            // Draw the mask on top (using drawImage to preserve transparency compositing)
            previewCtx.drawImage(maskCanvas, 0, 0);

            // Eye point markers - hidden by default, code kept for potential future use
            // To show markers, set showEyeMarkers = true
            const showEyeMarkers = false;
            if (showEyeMarkers) {
                if (eyePoints.left) {
                    drawMarker(eyePoints.left.x, eyePoints.left.y, '#00ff00');
                }
                if (eyePoints.right) {
                    drawMarker(eyePoints.right.x, eyePoints.right.y, '#00ff00');
                }
            }
        }

        function drawStrokeEffect(maskCanvas) {
            if (!maskCanvas || !previewCtx) return;

            // Create white silhouette from mask
            const silhouette = document.createElement('canvas');
            silhouette.width = maskCanvas.width;
            silhouette.height = maskCanvas.height;
            const silCtx = silhouette.getContext('2d');
            silCtx.drawImage(maskCanvas, 0, 0);
            silCtx.globalCompositeOperation = 'source-in';
            silCtx.fillStyle = 'white';
            silCtx.fillRect(0, 0, silhouette.width, silhouette.height);

            // Draw white silhouette offset in 8 directions (creates stroke)
            const strokeWidth = 4;
            const offsets = [
                [-strokeWidth, 0], [strokeWidth, 0], [0, -strokeWidth], [0, strokeWidth],
                [-strokeWidth, -strokeWidth], [strokeWidth, -strokeWidth],
                [-strokeWidth, strokeWidth], [strokeWidth, strokeWidth]
            ];

            offsets.forEach(([ox, oy]) => {
                previewCtx.drawImage(silhouette, ox, oy);
            });
        }

        // Draw mask with stroke (if enabled) for saving - returns the canvas ready for toDataURL
        function drawMaskForSave() {
            if (!previewCanvas || !previewCtx || !currentMaskData) return;

            // Clear canvas
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

            // Create temp canvas with mask
            const maskCanvas = document.createElement('canvas');
            maskCanvas.width = previewCanvas.width;
            maskCanvas.height = previewCanvas.height;
            const maskCtx = maskCanvas.getContext('2d');
            maskCtx.putImageData(currentMaskData, 0, 0);

            // Draw stroke if enabled
            if (strokeEnabled) {
                drawStrokeEffect(maskCanvas);
            }

            // Draw the mask on top
            previewCtx.drawImage(maskCanvas, 0, 0);
        }

        function drawMarker(x, y, color) {
            const radius = Math.max(15, previewCanvas.width * 0.02);

            // Outer circle
            previewCtx.strokeStyle = color;
            previewCtx.lineWidth = 3;
            previewCtx.beginPath();
            previewCtx.arc(x, y, radius, 0, Math.PI * 2);
            previewCtx.stroke();

            // Inner dot
            previewCtx.fillStyle = color;
            previewCtx.beginPath();
            previewCtx.arc(x, y, 4, 0, Math.PI * 2);
            previewCtx.fill();

            // Crosshairs
            previewCtx.beginPath();
            previewCtx.moveTo(x - radius - 5, y);
            previewCtx.lineTo(x - radius + 8, y);
            previewCtx.moveTo(x + radius - 8, y);
            previewCtx.lineTo(x + radius + 5, y);
            previewCtx.moveTo(x, y - radius - 5);
            previewCtx.lineTo(x, y - radius + 8);
            previewCtx.moveTo(x, y + radius - 8);
            previewCtx.lineTo(x, y + radius + 5);
            previewCtx.stroke();
        }

        // Tolerance/Size slider - live update as you drag
        document.getElementById('toleranceSlider').addEventListener('input', (e) => {
            document.getElementById('toleranceValue').textContent = e.target.value;

            // If in erase mode, update eraser size
            if (eraseMode) {
                eraserSize = parseInt(e.target.value);
                return;
            }

            // Otherwise update tolerance and re-run background removal
            if (originalImageData && paperColor) {
                removeBackground();
                // Redraw eye point markers if any
                if (eyePoints.left) {
                    drawMarker(eyePoints.left.x, eyePoints.left.y, '#00ff00');
                }
                if (eyePoints.right) {
                    drawMarker(eyePoints.right.x, eyePoints.right.y, '#00ff00');
                }
            }
        });

        // ============================================
        // UI HELPERS
        // ============================================

        let trackStatusTimeout = null;
        function updateStatus(view, message) {
            const el = document.getElementById(view + 'Status');
            if (el) {
                el.textContent = message;
                // For track view, show/hide with timeout
                if (view === 'track') {
                    el.style.display = 'block';
                    if (trackStatusTimeout) clearTimeout(trackStatusTimeout);
                    trackStatusTimeout = setTimeout(() => {
                        el.style.display = 'none';
                    }, 3000);
                }
            }
        }

        function showLoading(text) {
            document.getElementById('loadingText').textContent = text || 'Loading...';
            document.getElementById('loadingOverlay').classList.remove('hidden');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.add('hidden');
        }

        // ============================================
        // GROUP MANAGEMENT & SAVE MODAL
        // ============================================

        // Get/save groups from localStorage
        function getSavedGroups() {
            const saved = localStorage.getItem('mask_groups');
            return saved ? JSON.parse(saved) : [];
        }

        function saveGroupToStorage(groupName) {
            const groups = getSavedGroups();
            if (!groups.includes(groupName) && groupName !== 'default') {
                groups.push(groupName);
                localStorage.setItem('mask_groups', JSON.stringify(groups));
            }
        }

        function getLastGroup() {
            return localStorage.getItem('mask_last_group') || 'default';
        }

        function setLastGroup(groupName) {
            localStorage.setItem('mask_last_group', groupName);
        }

        // Auto-generate mask name from device and timestamp
        function generateMaskName() {
            // Get simple device name from userAgent
            const ua = navigator.userAgent;
            let device = 'Unknown';
            if (/iPhone/.test(ua)) device = 'iPhone';
            else if (/iPad/.test(ua)) device = 'iPad';
            else if (/Android/.test(ua)) device = 'Android';
            else if (/Mac/.test(ua)) device = 'Mac';
            else if (/Windows/.test(ua)) device = 'Windows';
            else if (/Linux/.test(ua)) device = 'Linux';

            // Format: "iPhone-Jan24-1430" (device-month-day-time)
            const now = new Date();
            const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            const month = months[now.getMonth()];
            const day = now.getDate();
            const time = now.getHours().toString().padStart(2,'0') + now.getMinutes().toString().padStart(2,'0');

            return `${device}-${month}${day}-${time}`;
        }

        // Show save group picker
        async function showSaveGroupPicker() {
            if (!eyePoints.left || !eyePoints.right) {
                updateStatus('capture', 'Please add eye points before saving');
                return;
            }

            const modal = document.getElementById('saveModal');
            const groupList = document.getElementById('saveGroupList');
            const publicBtn = document.getElementById('saveToPublicBtn');
            const newGroupBtn = document.getElementById('saveToNewGroupBtn');

            // Show Public option only for admins
            publicBtn.style.display = isAdmin ? 'flex' : 'none';

            // Show New Group only for admins (they create groups, then share links)
            newGroupBtn.style.display = isAdmin ? 'flex' : 'none';

            // Get friend tokens - these are groups the user can upload to
            const friendTokens = JSON.parse(localStorage.getItem('friend_tokens') || '{}');
            const friendGroupIds = Object.keys(friendTokens);

            let html = '';

            // Add Replace option if editing existing mask
            if (isEditingExistingMask && editingMask) {
                // Can replace if: local, or admin for public, or has token for friend group
                const canReplace = editingMaskGroup === 'local' ||
                                   (editingMaskGroup === 'public' && isAdmin) ||
                                   (isAdmin) ||
                                   (friendTokens[editingMaskGroup]);
                if (canReplace) {
                    html += `<button class="modal-btn primary" id="replaceOriginalBtn">Replace Original</button>`;
                }
            }

            // Show current group prominently if user has access (admin or friend token)
            if (currentGroup !== 'public' && currentGroup !== 'local' && (isAdmin || friendTokens[currentGroup])) {
                const groupDisplayName = currentGroupName || currentGroup;
                html += `<button class="modal-btn primary" data-save-group="${currentGroup}">${groupDisplayName}</button>`;
            }

            // For admin: fetch all groups from server
            // For regular users: only show friend groups they have tokens for
            const storedNames = JSON.parse(localStorage.getItem('group_names') || '{}');
            if (isAdmin) {
                try {
                    const response = await fetch(withAdmin(`${WORKER_URL}/groups`));
                    const data = await response.json();
                    if (data.groups && Array.isArray(data.groups)) {
                        const groups = data.groups.filter(g => g.id !== currentGroup);
                        if (groups.length > 0) {
                            html += groups.map(g => {
                                const name = (g.name || g.id) + '-masks';
                                const badge = g.type === 'friend' ? ' (friend)' : '';
                                return `<button class="modal-btn" data-save-group="${g.id}">${name}${badge}</button>`;
                            }).join('');
                        }
                    }
                } catch (e) {
                    console.error('Failed to fetch groups:', e);
                }
            } else if (friendGroupIds.length > 0) {
                // Show other friend groups user can upload to (not current)
                const otherGroups = friendGroupIds.filter(g => g !== currentGroup);
                if (otherGroups.length > 0) {
                    html += otherGroups.map(g => {
                        const name = (storedNames[g] || g) + '-masks';
                        return `<button class="modal-btn" data-save-group="${g}">${name}</button>`;
                    }).join('');
                }
            }

            groupList.innerHTML = html;

            // Add click handler for Replace Original
            const replaceBtn = document.getElementById('replaceOriginalBtn');
            if (replaceBtn) {
                replaceBtn.addEventListener('click', replaceOriginalMask);
            }

            // Add click handlers for group buttons
            groupList.querySelectorAll('[data-save-group]').forEach(btn => {
                btn.addEventListener('click', () => {
                    saveToGroup(btn.dataset.saveGroup);
                });
            });

            modal.classList.remove('hidden');
        }

        function hideSaveModal() {
            document.getElementById('saveModal').classList.add('hidden');
        }

        // Replace the original mask being edited
        async function replaceOriginalMask() {
            hideSaveModal();

            if (!editingMask || !editingMaskGroup) {
                updateStatus('capture', 'Error: No mask to replace');
                return;
            }

            // Redraw canvas with stroke if enabled, WITHOUT markers
            drawMaskForSave();

            const imageDataUrl = previewCanvas.toDataURL('image/png');

            // Build updated anchors (eyes only)
            const anchors = {};
            if (eyePoints.left && eyePoints.right) {
                anchors.leftEye = { x: eyePoints.left.x / previewCanvas.width, y: eyePoints.left.y / previewCanvas.height };
                anchors.rightEye = { x: eyePoints.right.x / previewCanvas.width, y: eyePoints.right.y / previewCanvas.height };
            }

            if (editingMaskGroup === 'local') {
                // Update local mask
                const localMasks = JSON.parse(localStorage.getItem('local_masks') || '[]');
                const maskIndex = localMasks.findIndex(m => m.id === editingMask.id);
                if (maskIndex !== -1) {
                    localMasks[maskIndex].image = imageDataUrl;
                    localMasks[maskIndex].anchors = anchors;
                    localStorage.setItem('local_masks', JSON.stringify(localMasks));
                }
                galleryManifest = null;
                updateStatus('capture', 'Mask updated!');
                isEditingExistingMask = false;
                editingMask = null;
                editingMaskGroup = null;
                document.getElementById('retakeBtn').textContent = 'Retake';
                setTimeout(async () => {
                    switchView('track');
                    await reloadCurrentMask();
                }, 1000);
            } else {
                // Update remote mask - upload new first, then delete old (safer)
                updateStatus('capture', 'Updating mask...');
                try {
                    // Build URL with auth
                    let uploadUrl = `${WORKER_URL}/upload`;
                    uploadUrl = withAdmin(uploadUrl);
                    uploadUrl = withToken(uploadUrl, editingMaskGroup);

                    // Upload the new version first
                    const response = await fetch(uploadUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            group: editingMaskGroup,
                            name: editingMask.name,
                            imageData: imageDataUrl,
                            anchors: anchors
                        })
                    });

                    if (!response.ok) {
                        const errData = await response.json().catch(() => ({}));
                        throw new Error(errData.error || 'Upload failed');
                    }

                    // Upload succeeded - now safe to delete the old one
                    let deleteUrl = `${WORKER_URL}/mask`;
                    deleteUrl = withAdmin(deleteUrl);

                    await fetch(deleteUrl, {
                        method: 'DELETE',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            group: editingMaskGroup,
                            maskId: editingMask.id
                        })
                    });

                    saveGroupToStorage(editingMaskGroup);
                    galleryManifest = null;
                    updateStatus('capture', 'Mask updated!');
                    isEditingExistingMask = false;
                    editingMask = null;
                    editingMaskGroup = null;
                    document.getElementById('retakeBtn').textContent = 'Retake';
                    setTimeout(async () => {
                        switchView('track');
                        await reloadCurrentMask();
                    }, 1000);
                } catch (error) {
                    updateStatus('capture', 'Error updating mask: ' + error.message);
                }
            }
        }

        // Save to local storage (for Local-masks group)
        function saveToPhone() {
            hideSaveModal();

            try {
                // Validate we have what we need
                if (!previewCanvas || !previewCtx) {
                    alert('Error: No mask to save');
                    return;
                }

                if (!currentMaskData) {
                    alert('Error: No mask data');
                    return;
                }

                if (!eyePoints.left || !eyePoints.right) {
                    alert('Error: Please place both eye locations first');
                    return;
                }

                const maskName = generateMaskName();

                // Redraw canvas with stroke if enabled, WITHOUT markers
                drawMaskForSave();

                const imageDataUrl = previewCanvas.toDataURL('image/png');
                const maskId = 'local-' + Date.now();

                // Build anchors
                const anchors = {
                    leftEye: { x: eyePoints.left.x / previewCanvas.width, y: eyePoints.left.y / previewCanvas.height },
                    rightEye: { x: eyePoints.right.x / previewCanvas.width, y: eyePoints.right.y / previewCanvas.height }
                };

                // Save to localStorage
                const localMasks = JSON.parse(localStorage.getItem('local_masks') || '[]');
                localMasks.push({
                    id: maskId,
                    name: maskName,
                    image: imageDataUrl,
                    anchors: anchors
                });
                localStorage.setItem('local_masks', JSON.stringify(localMasks));

                // Clear gallery cache so it reloads
                galleryManifest = null;

                // Reset edit state
                isEditingExistingMask = false;
                editingMask = null;
                editingMaskGroup = null;
                document.getElementById('retakeBtn').textContent = 'Retake';

                // Hide edit-specific UI
                document.getElementById('editControls').classList.add('hidden');
                document.getElementById('editHelpText').classList.add('hidden');
                document.getElementById('eyeControls').classList.add('hidden');
                document.getElementById('toleranceRow').classList.add('hidden');
                eyePointMode = false;
                placingEye = null;
                eraseMode = false;

                updateStatus('capture', `"${maskName}" saved to Local-masks!`);

                // Redraw markers so user sees clean state while waiting
                drawEyePointMarkers();

                // Return to play mode after a brief delay and reload mask
                setTimeout(async () => {
                    try {
                        switchView('track');
                        await reloadCurrentMask();
                    } catch (error) {
                        console.error('Error after save:', error);
                        switchView('track');
                    }
                }, 1000);

            } catch (error) {
                console.error('Save failed:', error);
                alert('Save failed: ' + error.message);
            }
        }

        // Show create group prompt
        function showCreateGroup() {
            showCreateGroupModal((groupName) => {
                saveToGroup(groupName);
            });
        }

        // Save to a group
        async function saveToGroup(groupName) {
            hideSaveModal();

            const maskName = generateMaskName();

            updateStatus('capture', 'Saving to ' + groupName + '...');

            try {
                // Redraw canvas with stroke if enabled, WITHOUT markers
                drawMaskForSave();

                const imageDataUrl = previewCanvas.toDataURL('image/png');

                // Debug: show image size
                const sizeKB = Math.round(imageDataUrl.length / 1024);
                console.log(`Image size: ${sizeKB}KB, dimensions: ${previewCanvas.width}x${previewCanvas.height}`);

                const anchors = {
                    leftEye: { x: eyePoints.left.x / previewCanvas.width, y: eyePoints.left.y / previewCanvas.height },
                    rightEye: { x: eyePoints.right.x / previewCanvas.width, y: eyePoints.right.y / previewCanvas.height }
                };

                updateStatus('capture', `Uploading ${sizeKB}KB to ${groupName}...`);

                // Build URL with auth
                let uploadUrl = `${WORKER_URL}/upload`;
                uploadUrl = withAdmin(uploadUrl);
                uploadUrl = withToken(uploadUrl, groupName);

                const response = await fetch(uploadUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        group: groupName,
                        name: maskName,
                        imageData: imageDataUrl,
                        anchors: anchors
                    })
                });

                const result = await response.json();
                if (!response.ok) throw new Error(result.error || 'Upload failed');

                // Save group to storage
                saveGroupToStorage(groupName);
                setLastGroup(groupName);

                // Clear for next time
                galleryManifest = null;

                // Reset edit state
                isEditingExistingMask = false;
                editingMask = null;
                editingMaskGroup = null;
                document.getElementById('retakeBtn').textContent = 'Retake';

                updateStatus('capture', `"${maskName}" saved to ${groupName}!`);

                // Return to play mode after a brief delay and reload mask
                setTimeout(async () => {
                    switchView('track');
                    await reloadCurrentMask();
                }, 1000);

            } catch (error) {
                console.error('Save error:', error);
                drawEyePointMarkers();
                updateStatus('capture', 'Save failed: ' + error.message);
                alert('Save failed: ' + error.message);
            }
        }

        // Share Group Modal
        function showShareModal() {
            const modal = document.getElementById('shareModal');
            const urlEl = document.getElementById('shareUrl');
            const qrEl = document.getElementById('qrCode');
            const btnText = document.getElementById('shareButtonText');

            btnText.textContent = 'Share Mask Maker with friends';

            const shareUrl = 'https://dbgh.uk/m';
            urlEl.textContent = shareUrl;

            // Generate QR code
            qrEl.innerHTML = '';
            new QRCode(qrEl, {
                text: shareUrl,
                width: 180,
                height: 180,
                colorDark: '#000000',
                colorLight: '#ffffff'
            });

            modal.classList.remove('hidden');
        }

        function hideShareModal() {
            document.getElementById('shareModal').classList.add('hidden');
        }

        function copyShareLink() {
            const url = 'https://dbgh.uk/m';
            navigator.clipboard.writeText(url).then(() => {
                alert('Link copied!');
            });
        }

        function shareLink() {
            // For friend groups, use the friend URL; otherwise use group URL
            let url, shareName;
            if (currentGroup === 'local') {
                url = 'https://dbgh.uk/m';
                shareName = 'Mask Maker';
            } else if (currentGroup === 'public') {
                url = 'https://dbgh.uk/m';
                shareName = 'Mask Maker';
            } else {
                // Custom group - use friendly name and appropriate URL
                shareName = currentGroupName || currentGroup;
                // Friend groups use ?friend=, others use ?group=
                if (currentGroup.startsWith('f_')) {
                    url = `https://dbgh.uk/m?friend=${currentGroup}`;
                } else {
                    url = `https://dbgh.uk/m?group=${currentGroup}`;
                }
            }
            if (navigator.share) {
                navigator.share({
                    title: shareName,
                    text: `Try ${shareName}!`,
                    url: url
                });
            } else {
                navigator.clipboard.writeText(url).then(() => {
                    alert('Link copied!');
                });
            }
        }

        // Create Group Modal
        let createGroupCallback = null;

        function generateRandomCode() {
            const chars = 'abcdefghjkmnpqrstuvwxyz23456789';
            let code = '';
            for (let i = 0; i < 5; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function updateGroupPreview() {
            const input = document.getElementById('createGroupNameInput');
            const checkbox = document.getElementById('addRandomSuffix');
            const preview = document.getElementById('groupNamePreview');

            let name = input.value.toLowerCase().replace(/[^a-z0-9-_]/g, '') || '';
            if (name && checkbox.checked) {
                name += '-' + generateRandomCode();
            }
            name += '-masks';

            preview.textContent = name;
            preview.dataset.finalName = name;
        }

        function showCreateGroupModal(callback) {
            createGroupCallback = callback;
            const modal = document.getElementById('createGroupModal');
            const input = document.getElementById('createGroupNameInput');

            // Reset state
            input.value = '';
            document.getElementById('addRandomSuffix').checked = true;
            updateGroupPreview();

            modal.classList.remove('hidden');
            input.focus();
        }

        function hideCreateGroupModal() {
            document.getElementById('createGroupModal').classList.add('hidden');
            createGroupCallback = null;
        }

        function confirmCreateGroup() {
            const preview = document.getElementById('groupNamePreview');
            const input = document.getElementById('createGroupNameInput');
            const baseName = input.value.toLowerCase().replace(/[^a-z0-9-_]/g, '');

            if (!baseName) {
                alert('Please enter a group name');
                return;
            }

            const finalName = preview.dataset.finalName;
            const callback = createGroupCallback; // Save before hiding clears it
            hideCreateGroupModal();

            if (callback) {
                callback(finalName);
            }
        }

        // Setup Create Group Modal events
        document.getElementById('createGroupNameInput').addEventListener('input', updateGroupPreview);
        document.getElementById('addRandomSuffix').addEventListener('change', updateGroupPreview);
        document.getElementById('confirmCreateGroupBtn').addEventListener('click', confirmCreateGroup);
        document.getElementById('cancelCreateGroupBtn').addEventListener('click', hideCreateGroupModal);
        document.getElementById('createGroupNameInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') confirmCreateGroup();
        });

        // Group Picker Modal (for switching groups only, no edit)
        async function showGroupPicker() {
            const modal = document.getElementById('groupPickerModal');
            const list = document.getElementById('groupPickerList');

            // Get local saved groups
            let localGroups = getSavedGroups().filter(g => g !== 'public' && g !== 'local');

            // Store group info (id -> name mapping)
            let groupInfo = {};

            // Try to fetch group registry for friendly names
            try {
                const url = isAdmin ? withAdmin(`${WORKER_URL}/groups`) : `${WORKER_URL}/groups/public`;
                const response = await fetch(url);
                const data = await response.json();
                if (data.groups && Array.isArray(data.groups)) {
                    // data.groups is an array: [{ id, name, type, ... }]
                    data.groups.forEach(g => {
                        groupInfo[g.id] = g.name || g.id;
                        // Add to list if not already there
                        if (!localGroups.includes(g.id)) {
                            localGroups.push(g.id);
                        }
                    });
                }
            } catch (e) {
                console.error('Failed to fetch group registry:', e);
            }

            // Also check friend tokens for accessible groups
            const friendTokens = JSON.parse(localStorage.getItem('friend_tokens') || '{}');
            Object.keys(friendTokens).forEach(token => {
                if (!localGroups.includes(token)) {
                    localGroups.push(token);
                }
            });

            // Load stored group names from localStorage
            const storedNames = JSON.parse(localStorage.getItem('group_names') || '{}');
            Object.entries(storedNames).forEach(([id, name]) => {
                if (!groupInfo[id]) {
                    groupInfo[id] = name;
                }
            });

            // Sort alphabetically by display name
            localGroups.sort((a, b) => {
                const nameA = groupInfo[a] || a;
                const nameB = groupInfo[b] || b;
                return nameA.localeCompare(nameB);
            });

            let html = `
                <button class="modal-btn ${currentGroup === 'public' ? 'selected' : ''}" data-group="public">
                    ${isAdmin ? '* ' : ''}Public-masks
                </button>
                <button class="modal-btn ${currentGroup === 'local' ? 'selected' : ''}" data-group="local">
                    Local-masks
                </button>
            `;

            localGroups.forEach(g => {
                const baseName = groupInfo[g] || g;
                const displayName = baseName + '-masks';
                const isFriend = g.startsWith('f_');
                const isPublicGroup = g.startsWith('g_');
                const badge = isAdmin ? (isFriend ? ' (friend)' : (isPublicGroup ? ' (public)' : '')) : '';
                html += `
                    <button class="modal-btn ${currentGroup === g ? 'selected' : ''}" data-group="${g}">
                        ${displayName}${badge}
                    </button>
                `;
            });

            list.innerHTML = html;

            list.querySelectorAll('[data-group]').forEach(btn => {
                btn.addEventListener('click', () => {
                    switchToGroup(btn.dataset.group);
                });
            });

            // Show share button if on a custom group (not public/local)
            const shareSection = document.getElementById('pickerShareSection');
            const shareBtn = document.getElementById('pickerShareBtn');
            if (currentGroup !== 'public' && currentGroup !== 'local') {
                shareSection.style.display = '';
                shareBtn.style.display = '';
                shareBtn.onclick = () => {
                    hideGroupPicker();
                    showShareModal();
                };
            } else {
                shareSection.style.display = 'none';
                shareBtn.style.display = 'none';
            }

            // Show admin panel button for admins
            const adminSection = document.getElementById('pickerAdminSection');
            const adminBtn = document.getElementById('pickerAdminBtn');
            if (isAdmin) {
                adminSection.style.display = '';
                adminBtn.style.display = '';
                adminBtn.onclick = () => {
                    hideGroupPicker();
                    showAdminPanel();
                };
            } else {
                adminSection.style.display = 'none';
                adminBtn.style.display = 'none';
            }

            modal.classList.remove('hidden');
        }

        function hideGroupPicker() {
            document.getElementById('groupPickerModal').classList.add('hidden');
        }

        function switchToGroup(groupName) {
            setLastGroup(groupName);
            window.location.href = buildUrl({ group: groupName });
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================

        // Gallery
        document.getElementById('galleryBtn').addEventListener('click', () => {
            toggleMenu(false);
            openGallery();
        });
        document.getElementById('closeGalleryBtn').addEventListener('click', closeGallery);

        // Header share button
        document.getElementById('headerShareBtn').addEventListener('click', () => {
            toggleMenu(false);
            showShareModal();
        });

        // Save button - shows group selection for where to save
        document.getElementById('saveBtn').addEventListener('click', () => {
            showSaveGroupPicker();
        });

        // Old modal buttons (kept for compatibility)
        // Save modal buttons
        document.getElementById('saveToPublicBtn')?.addEventListener('click', () => saveToGroup('public'));
        document.getElementById('saveToLocalBtn')?.addEventListener('click', saveToPhone);
        document.getElementById('saveToNewGroupBtn')?.addEventListener('click', () => {
            hideSaveModal();
            showCreateGroupModal((groupName) => {
                saveToGroup(groupName);
            });
        });
        document.getElementById('saveCancelBtn')?.addEventListener('click', hideSaveModal);

        // Share Modal
        document.getElementById('shareLinkBtn').addEventListener('click', shareLink);
        document.getElementById('shareCancelBtn').addEventListener('click', hideShareModal);

        // Group Picker Modal
        document.getElementById('groupPickerCancelBtn').addEventListener('click', hideGroupPicker);

        // Edit Mask event handlers
        document.getElementById('closeEditBtn').addEventListener('click', closeEditMask);
        document.getElementById('resetPointsBtn').addEventListener('click', resetEditAnchors);

        document.querySelectorAll('.anchor-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                currentEditAnchor = btn.dataset.anchor;
                updateAnchorButtons();
                drawEditMask();
            });
        });

        document.getElementById('editMaskCanvas').addEventListener('click', (e) => {
            // Don't place anchors in texture mode
            if (textureStream) return;

            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (e.clientX - rect.left) * scaleX;
            const canvasY = (e.clientY - rect.top) * scaleY;
            placeEditAnchor(canvasX, canvasY);
        });

        // Texture mode buttons
        document.getElementById('textureBtn').addEventListener('click', startTextureMode);
        document.getElementById('cancelTextureBtn').addEventListener('click', stopTextureMode);
        document.getElementById('captureTextureBtn').addEventListener('click', captureTexture);
        document.getElementById('saveEditBtn').addEventListener('click', () => {
            if (currentGroup === 'public' && !isAdmin) {
                alert('You cannot save to the Public group. Please choose a different group.');
                return;
            }
            if (currentGroup === 'local') {
                saveToPhone();
            } else {
                // Use the edit mask publish function
                if (!editAnchors.leftEye || !editAnchors.rightEye) {
                    document.getElementById('editStatus').textContent = 'Please place both eye points';
                    return;
                }
                publishFromEditMask();
            }
        });

        // Create mask texture
        document.getElementById('createTextureBtn').addEventListener('click', startCreateTextureMode);
        document.getElementById('cancelCreateTextureBtn').addEventListener('click', stopCreateTextureMode);
        document.getElementById('captureCreateTextureBtn').addEventListener('click', captureCreateTexture);

        document.getElementById('takePhotoBtn').addEventListener('click', takePhoto);
        document.getElementById('loadPictureBtn').addEventListener('click', () => {
            document.getElementById('pictureInput').click();
        });
        document.getElementById('pictureInput').addEventListener('change', loadPictureFromFile);
        document.getElementById('retakeBtn').addEventListener('click', retakePhoto);

        // Close buttons in capture view
        document.getElementById('closeCaptureBtn').addEventListener('click', () => {
            switchView('track');
        });
        document.getElementById('closeCreateBtn').addEventListener('click', () => {
            switchView('track');
        });

        // Tap on preview canvas - either cut holes or place eye points (not in erase mode)
        function handleCanvasTap(e) {
            if (eraseMode) return;

            const canvas = document.getElementById('previewCanvas');
            const rect = canvas.getBoundingClientRect();

            let clientX, clientY;
            if (e.changedTouches) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (clientX - rect.left) * scaleX;
            const canvasY = (clientY - rect.top) * scaleY;

            if (eyePointMode) {
                placeEyePoint(canvasX, canvasY);
            } else {
                cutHoleAtPoint(canvasX, canvasY);
            }
        }

        document.getElementById('previewCanvas').addEventListener('click', handleCanvasTap);
        document.getElementById('previewCanvas').addEventListener('touchend', (e) => {
            if (eraseMode) return;
            if (eyePointMode) {
                e.preventDefault();
                handleCanvasTap(e);
            }
        });

        // Erase mode - touch/mouse events for dragging
        const previewCanvasEl = document.getElementById('previewCanvas');
        let eraseStartTimeout = null;
        let pendingEraseCoords = null;

        function handleEraseStart(e) {
            if (!eraseMode) return;
            // Multi-touch - cancel any pending erase and don't start
            if (e.touches && e.touches.length > 1) {
                if (eraseStartTimeout) {
                    clearTimeout(eraseStartTimeout);
                    eraseStartTimeout = null;
                }
                isErasing = false;
                return;
            }

            const coords = getCanvasCoords(e, previewCanvasEl);

            // Mouse - erase immediately
            if (!e.touches) {
                e.preventDefault();
                isErasing = true;
                eraseAtPoint(coords.x, coords.y);
                return;
            }

            // Touch - delay to detect multi-touch gesture
            pendingEraseCoords = coords;
            eraseStartTimeout = setTimeout(() => {
                if (pendingEraseCoords) {
                    isErasing = true;
                    eraseAtPoint(pendingEraseCoords.x, pendingEraseCoords.y);
                    pendingEraseCoords = null;
                }
                eraseStartTimeout = null;
            }, 80);
        }

        function handleEraseMove(e) {
            if (!eraseMode) return;
            // Multi-touch - cancel erase mode
            if (e.touches && e.touches.length > 1) {
                if (eraseStartTimeout) {
                    clearTimeout(eraseStartTimeout);
                    eraseStartTimeout = null;
                    pendingEraseCoords = null;
                }
                isErasing = false;
                return;
            }
            if (!isErasing) return;
            e.preventDefault();
            const coords = getCanvasCoords(e, previewCanvasEl);
            eraseAtPoint(coords.x, coords.y);
        }

        function handleEraseEnd(e) {
            if (!eraseMode) return;
            if (eraseStartTimeout) {
                clearTimeout(eraseStartTimeout);
                eraseStartTimeout = null;
                pendingEraseCoords = null;
            }
            if (isErasing) {
                isErasing = false;
                // Save state after erasing
                currentMaskData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);
            }
        }

        previewCanvasEl.addEventListener('mousedown', handleEraseStart);
        previewCanvasEl.addEventListener('mousemove', handleEraseMove);
        previewCanvasEl.addEventListener('mouseup', handleEraseEnd);
        previewCanvasEl.addEventListener('mouseleave', handleEraseEnd);

        previewCanvasEl.addEventListener('touchstart', handleEraseStart, { passive: false });
        previewCanvasEl.addEventListener('touchmove', handleEraseMove, { passive: false });
        previewCanvasEl.addEventListener('touchend', handleEraseEnd);
        previewCanvasEl.addEventListener('touchcancel', handleEraseEnd);

        // Eye placement buttons
        document.getElementById('eyeRightBtn').addEventListener('click', () => {
            if (placingEye === 'right') {
                exitEyePointMode();
            } else {
                startPlacingEye('right');
            }
        });

        document.getElementById('eyeLeftBtn').addEventListener('click', () => {
            if (placingEye === 'left') {
                exitEyePointMode();
            } else {
                startPlacingEye('left');
            }
        });

        // Erase button
        document.getElementById('eraseBtn').addEventListener('click', () => {
            if (eraseMode) {
                exitEraseMode();
            } else {
                enterEraseMode();
            }
        });

        // Stroke button - commented out for now
        // document.getElementById('strokeBtn').addEventListener('click', () => {
        //     strokeEnabled = !strokeEnabled;
        //     document.getElementById('strokeBtn').classList.toggle('active', strokeEnabled);
        //     drawEyePointMarkers();
        // });

        // Clear Points button

        window.addEventListener('resize', () => {
            if (trackCanvas && isTracking) resizeTrackCanvas();
        });

        // Two-finger gesture handling for mask adjustment on main camera view
        (function setupMaskGestures() {
            const overlay = document.getElementById('tapOverlay');
            const container = overlay.parentElement;
            let gestureState = null;

            // Prevent Safari's native gesture events on the overlay
            overlay.addEventListener('gesturestart', (e) => e.preventDefault(), { passive: false });
            overlay.addEventListener('gesturechange', (e) => e.preventDefault(), { passive: false });
            overlay.addEventListener('gestureend', (e) => e.preventDefault(), { passive: false });

            // Also prevent on container
            container.addEventListener('gesturestart', (e) => e.preventDefault(), { passive: false });
            container.addEventListener('gesturechange', (e) => e.preventDefault(), { passive: false });
            container.addEventListener('gestureend', (e) => e.preventDefault(), { passive: false });

            // Prevent document-level zoom when touching the overlay
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length > 1 && overlay.contains(e.target)) {
                    e.preventDefault();
                }
            }, { passive: false });

            function getTouchData(e) {
                if (e.touches.length < 2) return null;
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                const centerX = (t1.clientX + t2.clientX) / 2;
                const centerY = (t1.clientY + t2.clientY) / 2;
                const dx = t2.clientX - t1.clientX;
                const dy = t2.clientY - t1.clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                return { centerX, centerY, distance, angle };
            }

            overlay.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    // Only allow when in position editing mode
                    if (!isEditingPosition) return;

                    // Need a mask loaded to adjust
                    if (!loadedMaskId) return;

                    e.preventDefault();
                    e.stopPropagation();

                    const data = getTouchData(e);
                    gestureState = {
                        lastDistance: data.distance,
                        lastAngle: data.angle,
                        lastCenterX: data.centerX,
                        lastCenterY: data.centerY
                    };
                }
            }, { passive: false });

            overlay.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2 && gestureState && loadedMask) {
                    e.preventDefault();
                    e.stopPropagation();
                    const data = getTouchData(e);

                    // Calculate incremental changes
                    const scaleRatio = data.distance / gestureState.lastDistance;
                    const rotationDelta = data.angle - gestureState.lastAngle;
                    const panX = data.centerX - gestureState.lastCenterX;
                    const panY = data.centerY - gestureState.lastCenterY;

                    // Apply directly to anchors
                    adjustAnchors(scaleRatio, rotationDelta, panX, panY);

                    // Update last values for next frame
                    gestureState.lastDistance = data.distance;
                    gestureState.lastAngle = data.angle;
                    gestureState.lastCenterX = data.centerX;
                    gestureState.lastCenterY = data.centerY;
                }
            }, { passive: false });

            overlay.addEventListener('touchend', (e) => {
                if (e.touches.length < 2) {
                    if (gestureState) {
                        saveCurrentMaskAnchors();
                    }
                    gestureState = null;
                }
            });

            overlay.addEventListener('touchcancel', () => {
                if (gestureState) {
                    saveCurrentMaskAnchors();
                }
                gestureState = null;
            });
        })();

        // Group Menu Modal
        function showGroupMenu() {
            const modal = document.getElementById('groupMenuModal');
            const shareBtn = document.getElementById('shareGroupBtn');
            const shareSection = document.getElementById('shareSection');
            const savedGroupsList = document.getElementById('savedGroupsList');
            const publicBtn = document.getElementById('publicGroupBtn');
            const localBtn = document.getElementById('localGroupBtn');
            const adminSection = document.getElementById('adminSection');
            const adminPanelBtn = document.getElementById('adminPanelBtn');

            // Highlight current selection
            publicBtn.classList.toggle('selected', currentGroup === 'public');
            localBtn.classList.toggle('selected', currentGroup === 'local');

            // Show admin section only for admins
            adminSection.style.display = isAdmin ? 'block' : 'none';
            adminPanelBtn.style.display = isAdmin ? 'flex' : 'none';

            // Show share button only for shared groups (not public, not local)
            if (currentGroup !== 'public' && currentGroup !== 'local') {
                shareBtn.style.display = 'flex';
                shareSection.style.display = 'block';
            } else {
                shareBtn.style.display = 'none';
                shareSection.style.display = 'none';
            }

            // Build saved groups list (exclude public and local as they have fixed buttons)
            const groups = getSavedGroups().filter(g => g !== 'public' && g !== 'local');
            if (groups.length > 0) {
                savedGroupsList.innerHTML = groups.map(g => `
                    <button class="modal-btn ${currentGroup === g ? 'selected' : ''}" data-group="${g}">
                        ${g}
                    </button>
                `).join('');

                savedGroupsList.querySelectorAll('[data-group]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        selectGroupAndMake(btn.dataset.group);
                    });
                });
            } else {
                savedGroupsList.innerHTML = '';
            }

            modal.classList.remove('hidden');
        }

        function hideGroupMenu() {
            document.getElementById('groupMenuModal').classList.add('hidden');
        }

        // Export local masks to file
        function exportLocalMasks() {
            const localMasks = JSON.parse(localStorage.getItem('local_masks') || '[]');
            if (localMasks.length === 0) {
                alert('No local masks to export');
                return;
            }

            const exportData = {
                version: 1,
                exported: new Date().toISOString(),
                type: 'local_masks',
                masks: localMasks
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `masks-backup-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            alert(`Exported ${localMasks.length} masks`);
        }

        // Import masks from file
        function importLocalMasks(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    if (!data.masks || !Array.isArray(data.masks)) {
                        alert('Invalid backup file');
                        return;
                    }

                    const localMasks = JSON.parse(localStorage.getItem('local_masks') || '[]');
                    let imported = 0;

                    data.masks.forEach(mask => {
                        // Check if mask already exists (by id)
                        const exists = localMasks.some(m => m.id === mask.id);
                        if (!exists && mask.id && mask.image) {
                            localMasks.push(mask);
                            imported++;
                        }
                    });

                    localStorage.setItem('local_masks', JSON.stringify(localMasks));
                    alert(`Imported ${imported} masks (${data.masks.length - imported} duplicates skipped)`);

                    // Refresh if on local group
                    if (currentGroup === 'local') {
                        window.location.reload();
                    }
                } catch (err) {
                    alert('Error reading file: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        // Select a group and go to make mask
        function selectGroupAndMake(groupName) {
            hideGroupMenu();

            // Non-admins can't make masks for public - just view instead
            if (groupName === 'public' && !isAdmin) {
                if (currentGroup !== 'public') {
                    window.location.href = buildUrl({ group: 'public' });
                }
                return;
            }

            saveGroupToStorage(groupName);
            setLastGroup(groupName);

            // If already on this group, just switch view directly
            if (currentGroup === groupName) {
                switchView('capture');
            } else {
                // Reload with new group and go to capture view
                window.location.href = buildUrl({ group: groupName }, '#capture');
            }
        }

        // Group name in header shows group picker when clicked (switch group only, no edit)
        document.getElementById('groupNameHeader').addEventListener('click', () => {
            toggleMenu(false);
            showGroupPicker();
        });

        document.getElementById('groupCloseBtn').addEventListener('click', hideGroupMenu);

        document.getElementById('publicGroupBtn').addEventListener('click', () => {
            selectGroupAndMake('public');
        });

        document.getElementById('localGroupBtn').addEventListener('click', () => {
            selectGroupAndMake('local');
        });

        // Export/Import buttons
        document.getElementById('exportLocalBtn').addEventListener('click', () => {
            hideGroupMenu();
            exportLocalMasks();
        });

        document.getElementById('importLocalBtn').addEventListener('click', () => {
            document.getElementById('importLocalInput').click();
        });

        document.getElementById('importLocalInput').addEventListener('change', (e) => {
            if (e.target.files[0]) {
                hideGroupMenu();
                importLocalMasks(e.target.files[0]);
                e.target.value = ''; // Reset for next import
            }
        });

        document.getElementById('newGroupBtn').addEventListener('click', () => {
            hideGroupMenu();
            showCreateGroupModal((groupName) => {
                saveGroupToStorage(groupName);
                // Navigate to new group with flag to show share modal and go to capture
                window.location.href = buildUrl({ group: groupName, new: 1 }, '#capture');
            });
        });

        document.getElementById('shareGroupBtn').addEventListener('click', () => {
            hideGroupMenu();
            showShareModal();
        });

        // Admin Panel
        document.getElementById('adminPanelBtn').addEventListener('click', () => {
            hideGroupMenu();
            showAdminPanel();
        });

        async function showAdminPanel() {
            const modal = document.getElementById('adminPanelModal');
            const groupsList = document.getElementById('adminGroupsList');
            groupsList.innerHTML = '<div style="text-align:center;color:#888;padding:20px;">Loading groups...</div>';
            modal.classList.remove('hidden');

            // Fetch all groups from server
            try {
                const response = await fetch(withAdmin(`${WORKER_URL}/groups`));
                if (!response.ok) throw new Error('Failed to fetch groups');
                const data = await response.json();

                if (!data.groups || !Array.isArray(data.groups) || data.groups.length === 0) {
                    groupsList.innerHTML = '<div style="text-align:center;color:#888;padding:20px;">No groups yet</div>';
                    return;
                }

                // Sort: public first, then friend
                const publicGroups = data.groups.filter(g => g.type === 'public');
                const friendGroups = data.groups.filter(g => g.type === 'friend');

                let html = '';
                if (publicGroups.length > 0) {
                    html += '<div style="font-size:11px;margin:8px 0 4px 0;">Public Groups</div>';
                    publicGroups.forEach(g => {
                        const displayName = (g.name || g.id) + '-masks';
                        html += `
                            <div style="display:flex;align-items:center;justify-content:space-between;padding:8px;background:#222;border-radius:4px;margin-bottom:4px;">
                                <div style="flex:1;">
                                    <div style="font-size:14px;">${displayName}</div>
                                    <div style="font-size:10px;color:#666;">${g.id}</div>
                                </div>
                                <div style="display:flex;gap:4px;">
                                    <button class="modal-btn admin-goto-btn" data-group="${g.id}" style="width:auto;padding:6px 12px;margin:0;">View</button>
                                    <button class="modal-btn admin-delete-btn" data-group="${g.id}" data-name="${displayName}" style="width:auto;padding:6px 12px;margin:0;background:#a33;">Delete</button>
                                </div>
                            </div>
                        `;
                    });
                }

                if (friendGroups.length > 0) {
                    html += '<div style="font-size:11px;margin:12px 0 4px 0;">Friend Groups</div>';
                    friendGroups.forEach(g => {
                        const isRevoked = g.revoked;
                        const displayName = (g.name || g.id) + '-masks';
                        html += `
                            <div style="display:flex;align-items:center;justify-content:space-between;padding:8px;background:#222;border-radius:4px;margin-bottom:4px;${isRevoked ? 'opacity:0.5;' : ''}">
                                <div style="flex:1;">
                                    <div style="font-size:14px;">${displayName} ${isRevoked ? '(revoked)' : ''}</div>
                                    <div style="font-size:10px;color:#666;">${g.id}</div>
                                </div>
                                <div style="display:flex;gap:4px;flex-wrap:wrap;">
                                    <button class="modal-btn admin-goto-btn" data-group="${g.id}" style="width:auto;padding:6px 12px;margin:0;">View</button>
                                    <button class="modal-btn admin-copy-btn" data-group="${g.id}" style="width:auto;padding:6px 12px;margin:0;">Copy</button>
                                    <button class="modal-btn admin-revoke-btn" data-group="${g.id}" style="width:auto;padding:6px 12px;margin:0;">${isRevoked ? 'Unrevoke' : 'Revoke'}</button>
                                    <button class="modal-btn admin-delete-btn" data-group="${g.id}" data-name="${displayName}" style="width:auto;padding:6px 12px;margin:0;background:#a33;">Delete</button>
                                </div>
                            </div>
                        `;
                    });
                }

                groupsList.innerHTML = html;

                // Add event handlers
                groupsList.querySelectorAll('.admin-goto-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const groupId = btn.dataset.group;
                        modal.classList.add('hidden');
                        window.location.href = buildUrl({ group: groupId });
                    });
                });

                groupsList.querySelectorAll('.admin-copy-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const groupId = btn.dataset.group;
                        const url = `${window.location.origin}${window.location.pathname}?friend=${groupId}`;
                        navigator.clipboard.writeText(url).then(() => {
                            alert('Link copied: ' + url);
                        }).catch(() => {
                            prompt('Copy this link:', url);
                        });
                    });
                });

                groupsList.querySelectorAll('.admin-revoke-btn').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        const groupId = btn.dataset.group;
                        if (!confirm(`Revoke access to ${groupId}? Existing links will stop working.`)) return;

                        try {
                            const response = await fetch(withAdmin(`${WORKER_URL}/group/revoke`), {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ groupId })
                            });

                            if (!response.ok) throw new Error('Failed to revoke');
                            alert('Group revoked');
                            showAdminPanel(); // Refresh
                        } catch (err) {
                            alert('Error: ' + err.message);
                        }
                    });
                });

                groupsList.querySelectorAll('.admin-delete-btn').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        const groupId = btn.dataset.group;
                        const groupName = btn.dataset.name;
                        if (!confirm(`DELETE ${groupName}?\n\nThis will permanently remove the group and ALL its masks. This cannot be undone!`)) return;
                        if (!confirm(`Are you SURE you want to delete ${groupName}? Type OK to confirm.`)) return;

                        try {
                            btn.textContent = 'Deleting...';
                            btn.disabled = true;

                            const response = await fetch(withAdmin(`${WORKER_URL}/group/delete`), {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ groupId })
                            });

                            if (!response.ok) {
                                const data = await response.json();
                                throw new Error(data.error || 'Failed to delete');
                            }

                            alert('Group deleted successfully');
                            showAdminPanel(); // Refresh
                        } catch (err) {
                            alert('Error: ' + err.message);
                            btn.textContent = 'Delete';
                            btn.disabled = false;
                        }
                    });
                });

            } catch (err) {
                groupsList.innerHTML = `<div style="text-align:center;color:#f44;padding:20px;">Error: ${err.message}</div>`;
            }
        }

        document.getElementById('createPublicGroupBtn').addEventListener('click', async () => {
            const name = prompt('Public group display name (e.g., "Holiday Masks"):');
            if (!name) return;

            try {
                const response = await fetch(withAdmin(`${WORKER_URL}/group/create`), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ type: 'public', name })
                });

                if (!response.ok) throw new Error('Failed to create group');
                const data = await response.json();
                alert(`Public group created!\nID: ${data.groupId}\nName: ${name}`);
                showAdminPanel(); // Refresh list
            } catch (err) {
                alert('Error: ' + err.message);
            }
        });

        document.getElementById('createFriendGroupBtn').addEventListener('click', async () => {
            const name = prompt('Friend group name (e.g., "Ben\'s Masks"):');
            if (!name) return;

            try {
                const response = await fetch(withAdmin(`${WORKER_URL}/group/create`), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ type: 'friend', name })
                });

                if (!response.ok) throw new Error('Failed to create group');
                const data = await response.json();

                const shareUrl = `${window.location.origin}${window.location.pathname}?friend=${data.groupId}`;

                // Copy to clipboard and show
                try {
                    await navigator.clipboard.writeText(shareUrl);
                    alert(`Friend group created!\n\nShare link (copied to clipboard):\n${shareUrl}`);
                } catch {
                    prompt('Friend group created! Copy this link to share:', shareUrl);
                }

                showAdminPanel(); // Refresh list
            } catch (err) {
                alert('Error: ' + err.message);
            }
        });

        document.getElementById('adminPanelCloseBtn').addEventListener('click', () => {
            document.getElementById('adminPanelModal').classList.add('hidden');
        });

        document.getElementById('adminLogoutBtn').addEventListener('click', () => {
            localStorage.removeItem('mask_admin');
            localStorage.removeItem('mask_admin_code');
            alert('Logged out of admin mode. Refreshing...');
            window.location.href = window.location.pathname;
        });

        // Debug helper
        function debug(msg) {
            const el = document.getElementById('debugInfo');
            el.innerHTML = msg + '<br>' + el.innerHTML;
            if (el.innerHTML.length > 500) el.innerHTML = el.innerHTML.substring(0, 500);
        }

        // Tap on screen to change masks
        // Left 1/4 = previous, Middle 1/2 = random, Right 1/4 = next
        document.getElementById('tapOverlay').addEventListener('click', async (e) => {
            // Load gallery if needed
            if (!galleryManifest || galleryManifest.masks.length === 0) {
                await loadGalleryManifest();
            }

            if (!galleryManifest || galleryManifest.masks.length === 0) {
                return;
            }

            // Determine tap zone
            const rect = e.target.getBoundingClientRect();
            const tapX = e.clientX - rect.left;
            const width = rect.width;
            const tapPosition = tapX / width;

            const oldIndex = currentMaskIndex;
            const numMasks = galleryManifest.masks.length;

            if (tapPosition < 0.25) {
                // Left quarter - previous mask
                currentMaskIndex = (currentMaskIndex - 1 + numMasks) % numMasks;
            } else if (tapPosition > 0.75) {
                // Right quarter - next mask
                currentMaskIndex = (currentMaskIndex + 1) % numMasks;
            } else {
                // Middle half - random mask (but not the same one)
                if (numMasks > 1) {
                    let newIndex;
                    do {
                        newIndex = Math.floor(Math.random() * numMasks);
                    } while (newIndex === currentMaskIndex);
                    currentMaskIndex = newIndex;
                }
            }

            // Load the new mask
            const mask = galleryManifest.masks[currentMaskIndex];
            try {
                await selectGalleryMask(mask);
            } catch (err) {
                console.error('Failed to load mask:', err);
            }
        });

        // Create built-in censor bar mask for empty groups
        function loadCensorBarMask() {
            // Create censor bar image
            const canvas = document.createElement('canvas');
            canvas.width = 1600;
            canvas.height = 320;
            const ctx = canvas.getContext('2d');

            // Black bar
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, 1600, 320);

            // White text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Empty group - Create Mask', 800, 160);

            // Create image from canvas
            const img = new Image();
            img.src = canvas.toDataURL();

            img.onload = () => {
                maskImage = img;
                loadedMask = {
                    width: 1600,
                    height: 320,
                    anchors: {
                        // Closer together = bigger mask on face
                        leftEye: { x: 0.6, y: 0.5 },
                        rightEye: { x: 0.4, y: 0.5 }
                    }
                };
            };
        }

        // Load a random mask from the gallery
        async function loadRandomMask() {
            try {
                await loadGalleryManifest();
                if (galleryManifest && galleryManifest.masks.length > 0) {
                    currentMaskIndex = Math.floor(Math.random() * galleryManifest.masks.length);
                    const randomMask = galleryManifest.masks[currentMaskIndex];
                    await selectGalleryMask(randomMask);
                } else {
                    // No masks in group - load censor bar
                    loadCensorBarMask();
                }
            } catch (error) {
                console.error('Failed to load random mask:', error);
                // Fallback to censor bar on error
                loadCensorBarMask();
            }
        }

        // ============================================
        // TITLE SCREEN MODULE - KEEP SEPARATE
        // ============================================

        const TitleModule = {
            WORKER_URL: 'https://mask-worker.dbgh.workers.dev',

            config: null,
            isAdmin: false,
            pendingImage: null,
            titleGroup: 'public', // group ID for title loading

            async init() {
                const urlParams = new URLSearchParams(window.location.search);

                // Check for admin mode
                if (urlParams.get('title') === 'admin') {
                    this.isAdmin = true;
                    this.showAdminPanel();
                    return false; // Don't continue to main app
                }

                // Determine title group - use actual group ID for per-group titles
                // Worker falls back to 'public' if group-specific title doesn't exist
                this.titleGroup = currentGroup;

                // Try to load title config - don't wait for click, just show it
                try {
                    this.config = await this.loadConfig(this.titleGroup);
                    if (this.config && this.config.configured && this.config.image) {
                        this.showTitleScreen(); // Don't await - app loads behind
                    }
                } catch (e) {
                    console.log('No title configured:', e.message);
                }

                return true; // Continue to main app immediately
            },

            async loadConfig(groupId = 'public') {
                const response = await fetch(`${this.WORKER_URL}/title?group=${groupId}`);
                if (!response.ok) return null;
                return await response.json();
            },

            showTitleScreen() {
                const overlay = document.getElementById('titleOverlay');
                const img = document.getElementById('titleImage');

                // Use jsDelivr with purge for better cache invalidation
                // Use raw GitHub URL to avoid jsDelivr caching issues
                const imageUrl = `https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/${this.config.image}?_=${this.config.updated || Date.now()}`;
                img.src = imageUrl;

                img.onload = () => {
                    overlay.classList.remove('hidden');

                    const dismiss = () => {
                        overlay.removeEventListener('click', dismiss);
                        overlay.classList.add('fade-out');
                        setTimeout(() => {
                            overlay.classList.add('hidden');
                        }, 500);
                    };

                    overlay.addEventListener('click', dismiss);
                };

                img.onerror = () => {
                    console.error('Failed to load title image');
                };
            },

            adminTitleType: 'public', // Currently selected in admin
            adminGroups: [], // Cached groups list

            showAdminPanel() {
                document.getElementById('titleAdminPanel').classList.remove('hidden');
                this.adminTitleType = 'public';
                this.updateAdminTypeButtons();
                this.loadCurrentTitle();
                this.setupAdminEvents();
            },

            updateAdminTypeButtons() {
                const publicBtn = document.getElementById('titleTypePublicBtn');
                const localBtn = document.getElementById('titleTypeLocalBtn');
                const groupBtn = document.getElementById('titleTypeGroupBtn');
                const groupSelect = document.getElementById('titleGroupSelect');
                const desc = document.getElementById('titleTypeDesc');

                const isGroup = this.adminTitleType !== 'public' && this.adminTitleType !== 'local';

                publicBtn.style.background = this.adminTitleType === 'public' ? '#4CAF50' : '#333';
                localBtn.style.background = this.adminTitleType === 'local' ? '#4CAF50' : '#333';
                groupBtn.style.background = isGroup ? '#4CAF50' : '#333';

                groupSelect.style.display = isGroup ? 'block' : 'none';

                if (this.adminTitleType === 'public') {
                    desc.textContent = 'Default title for all groups';
                } else if (this.adminTitleType === 'local') {
                    desc.textContent = 'Title for Local-masks';
                } else {
                    const group = this.adminGroups.find(g => g.id === this.adminTitleType);
                    const name = group ? group.name + '-masks' : this.adminTitleType;
                    desc.textContent = `Title for ${name}`;
                }
            },

            async loadGroups() {
                try {
                    // Use admin param directly since we're in title admin mode
                    const adminCode = localStorage.getItem('mask_admin_code') || '';
                    const response = await fetch(`${this.WORKER_URL}/groups?admin=${encodeURIComponent(adminCode)}`);
                    const data = await response.json();
                    if (data.groups && Array.isArray(data.groups)) {
                        this.adminGroups = data.groups;
                        const select = document.getElementById('titleGroupSelect');
                        select.innerHTML = '<option value="">Select a group...</option>' +
                            data.groups.map(g => `<option value="${g.id}">${(g.name || g.id)}-masks</option>`).join('');
                    }
                } catch (e) {
                    console.error('Failed to load groups:', e);
                }
            },

            async loadCurrentTitle() {
                const preview = document.getElementById('titlePreviewImg');
                const status = document.getElementById('titleAdminStatus');

                try {
                    const config = await this.loadConfig(this.adminTitleType);
                    if (config && config.configured && config.image) {
                        // Use raw GitHub URL to avoid jsDelivr caching issues
                        preview.src = `https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/${config.image}?_=${config.updated || Date.now()}`;
                        status.textContent = 'Current title loaded';
                    } else {
                        preview.src = '';
                        status.textContent = 'No title image configured';
                    }
                } catch (e) {
                    preview.src = '';
                    status.textContent = 'No title configured';
                }
            },

            setupAdminEvents() {
                const fileInput = document.getElementById('titleFileInput');
                const selectBtn = document.getElementById('titleSelectBtn');
                const uploadBtn = document.getElementById('titleUploadBtn');
                const removeBtn = document.getElementById('titleRemoveBtn');
                const closeBtn = document.getElementById('titleCloseBtn');
                const publicBtn = document.getElementById('titleTypePublicBtn');
                const localBtn = document.getElementById('titleTypeLocalBtn');
                const groupBtn = document.getElementById('titleTypeGroupBtn');
                const groupSelect = document.getElementById('titleGroupSelect');
                const preview = document.getElementById('titlePreviewImg');
                const status = document.getElementById('titleAdminStatus');

                publicBtn.addEventListener('click', () => {
                    this.adminTitleType = 'public';
                    this.updateAdminTypeButtons();
                    this.pendingImage = null;
                    uploadBtn.disabled = true;
                    this.loadCurrentTitle();
                });

                localBtn.addEventListener('click', () => {
                    this.adminTitleType = 'local';
                    this.updateAdminTypeButtons();
                    this.pendingImage = null;
                    uploadBtn.disabled = true;
                    this.loadCurrentTitle();
                });

                groupBtn.addEventListener('click', async () => {
                    await this.loadGroups();
                    this.adminTitleType = 'group'; // Temporary until they select
                    this.updateAdminTypeButtons();
                    this.pendingImage = null;
                    uploadBtn.disabled = true;
                    preview.src = '';
                    status.textContent = 'Select a group from the dropdown';
                });

                groupSelect.addEventListener('change', () => {
                    const groupId = groupSelect.value;
                    if (groupId) {
                        this.adminTitleType = groupId;
                        this.updateAdminTypeButtons();
                        this.pendingImage = null;
                        uploadBtn.disabled = true;
                        this.loadCurrentTitle();
                    }
                });

                selectBtn.addEventListener('click', () => fileInput.click());

                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        // Load image to resize it
                        const img = new Image();
                        img.onload = () => {
                            // Resize to max 1024px
                            const MAX_SIZE = 1024;
                            let width = img.width;
                            let height = img.height;

                            if (width > MAX_SIZE || height > MAX_SIZE) {
                                if (width > height) {
                                    height = Math.round(height * (MAX_SIZE / width));
                                    width = MAX_SIZE;
                                } else {
                                    width = Math.round(width * (MAX_SIZE / height));
                                    height = MAX_SIZE;
                                }
                            }

                            // Draw to canvas and get resized data URL
                            const canvas = document.createElement('canvas');
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);

                            this.pendingImage = canvas.toDataURL('image/png');
                            preview.src = this.pendingImage;
                            uploadBtn.disabled = false;
                            status.textContent = `Image ready (${width}x${height})`;
                        };
                        img.src = ev.target.result;
                    };
                    reader.readAsDataURL(file);
                });

                uploadBtn.addEventListener('click', async () => {
                    if (!this.pendingImage) return;
                    await this.uploadTitle();
                });

                removeBtn.addEventListener('click', async () => {
                    await this.removeTitle();
                });

                closeBtn.addEventListener('click', () => {
                    window.location.href = window.location.pathname;
                });
            },

            async uploadTitle() {
                const status = document.getElementById('titleAdminStatus');
                const uploadBtn = document.getElementById('titleUploadBtn');

                uploadBtn.disabled = true;
                status.textContent = 'Uploading...';

                // Image path depends on group type
                let imagePath;
                if (this.adminTitleType === 'local') {
                    imagePath = 'title/local-title-image.png';
                } else if (this.adminTitleType === 'public') {
                    imagePath = 'title/title-image.png';
                } else {
                    imagePath = `groups/${this.adminTitleType}/title-image.png`;
                }

                try {
                    const adminCode = localStorage.getItem('mask_admin_code') || '';
                    const response = await fetch(`${this.WORKER_URL}/title?admin=${encodeURIComponent(adminCode)}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ imageData: this.pendingImage, group: this.adminTitleType })
                    });

                    const result = await response.json();

                    if (!response.ok || result.error) {
                        throw new Error(result.error || 'Upload failed');
                    }

                    // Purge jsDelivr cache so new image shows immediately
                    status.textContent = 'Purging cache...';
                    try {
                        await fetch(`https://purge.jsdelivr.net/gh/${GITHUB_REPO}@${GITHUB_BRANCH}/${imagePath}`);
                    } catch (e) {
                        console.log('Cache purge failed (non-critical):', e);
                    }

                    status.textContent = 'Title uploaded successfully!';
                    this.pendingImage = null;
                    uploadBtn.disabled = true;

                } catch (error) {
                    console.error('Upload error:', error);
                    status.textContent = 'Upload failed: ' + error.message;
                    uploadBtn.disabled = false;
                }
            },

            async removeTitle() {
                const status = document.getElementById('titleAdminStatus');
                const preview = document.getElementById('titlePreviewImg');

                let typeName;
                if (this.adminTitleType === 'local') {
                    typeName = 'Local-masks';
                } else if (this.adminTitleType === 'public') {
                    typeName = 'Default';
                } else {
                    const group = this.adminGroups.find(g => g.id === this.adminTitleType);
                    typeName = group ? group.name + '-masks' : this.adminTitleType;
                }

                if (!confirm(`Remove the ${typeName} title screen?`)) return;

                status.textContent = 'Removing...';

                try {
                    const adminCode = localStorage.getItem('mask_admin_code') || '';
                    const response = await fetch(`${this.WORKER_URL}/title?group=${this.adminTitleType}&admin=${encodeURIComponent(adminCode)}`, {
                        method: 'DELETE'
                    });

                    const result = await response.json();

                    if (!response.ok || result.error) {
                        throw new Error(result.error || 'Remove failed');
                    }

                    preview.src = '';
                    status.textContent = 'Title removed';

                } catch (error) {
                    console.error('Remove error:', error);
                    status.textContent = 'Remove failed: ' + error.message;
                }
            }
        };

        // ============================================
        // INITIALIZATION
        // ============================================

        // Initialize directly (DOM is ready since module uses top-level await)
        (async () => {
            // Check if on mobile device - block desktop users
            // Note: iPadOS 13+ reports as "Macintosh", so also check for touch support
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ||
                             (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            if (!isMobile) {
                document.getElementById('desktopBlock').classList.remove('hidden');
                return; // Stop initialization
            }

            // Check title module first
            const continueToApp = await TitleModule.init();
            if (!continueToApp) return; // Admin mode, don't load app

            document.getElementById('loadingText').textContent = 'Initializing...';
            showLoading('Loading face detection...');

            // Check if we should go to capture view FIRST (from group selection)
            // Do this before async initialization so it happens immediately
            const shouldCapture = window.location.hash === '#capture';
            // Clear the hash right away
            if (shouldCapture) {
                history.replaceState(null, '', window.location.pathname + window.location.search);
            }
            // Only go to capture if allowed (non-admins can't capture on public)
            if (shouldCapture && (currentGroup !== 'public' || isAdmin)) {
                switchView('capture');
            }

            try {
                await initializeFaceLandmarker();
                // Load a random mask after initialization
                await loadRandomMask();

                // If this is a newly created group, show share modal
                if (isNewGroup) {
                    // Clean up the URL (remove &new=1)
                    history.replaceState(null, '', buildUrl({ group: currentGroup }));
                    // Show share modal after a brief delay so user sees the group first
                    setTimeout(() => {
                        showShareModal();
                    }, 500);
                }
            } catch (error) {
                console.error('Initialization error:', error);
                updateStatus('track', 'Error loading: ' + error.message);
                hideLoading();
            }
        })();
    </script>
</body>
</html>
